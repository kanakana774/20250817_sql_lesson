# **SQL 基礎：ウィンドウ関数の詳細**

## **導入：ウィンドウ関数とは？**

**ウィンドウ関数**は、特定の行のセット（**ウィンドウ**）に対して計算を実行し、その結果を**各行に返す**機能です。これは GROUP BY 句と大きく異なります。GROUP BY が集計によって行数を減らす（まとめる）のに対し、ウィンドウ関数は元の行数を維持したまま、集計結果やランキングなどを各行のコンテキストに付加できます。

これにより、ランキング、移動平均、累計、前後の行との比較など、より複雑なデータ分析やレポート作成が可能になります。

## **基本構文と構成要素**

ウィンドウ関数の基本構文は以下の通りです。

関数名() OVER (\[PARTITION BY 列リスト\] \[ORDER BY 列リスト \[ASC|DESC\] \[, ...\]\] \[ウィンドウフレーム\])

各構成要素について詳しく見ていきましょう。

- **関数名()**: 実行したいウィンドウ関数（例: ROW_NUMBER(), RANK(), SUM(), AVG(), LAG(), LEAD()など）。
- **OVER()句**: ウィンドウ関数であることを示し、その後の括弧内でウィンドウの定義を行います。
- **PARTITION BY 句 (オプション)**:
  - データを 1 つ以上の列の値に基づいて論理的なパーティション（グループ）に分割します。
  - このパーティション内で関数が独立して計算されます。GROUP BY のグループ化と似ていますが、行は集約されません。
- **ORDER BY 句 (オプション)**:
  - 各パーティション内で、行の順序を定義します。
  - ランキング関数や移動平均などで非常に重要です。
- **ウィンドウフレーム (オプション)**:
  - ORDER BY 句と組み合わせて、現在の行を中心とした計算範囲（フレーム）を定義します。
  - ROWS、RANGE、GROUPS の 3 種類があり、それぞれ挙動が異なります。

## **PARTITION BY と ORDER BY の省略時の挙動**

OVER()句内の PARTITION BY や ORDER BY を省略した場合、ウィンドウ関数の挙動は以下のように変化します。

### **1\. PARTITION BY を省略した場合**

PARTITION BY 句が省略された場合、**クエリ結果セット全体が 1 つの大きなパーティションとして扱われます。** つまり、ウィンドウ関数はデータ全体に対して計算を実行します。

**例: テーブル全体のランキング**

employees テーブル（社員名と給与）を想定します。

**事前データ:**

employees テーブル:

| employee_id | employee_name | salary |
| :---------- | :------------ | :----- |
| 1           | Alice         | 5000   |
| 2           | Bob           | 6000   |
| 3           | Charlie       | 4500   |
| 4           | David         | 7000   |

**SQL:**

SELECT  
 employee_name,  
 salary,  
 ROW_NUMBER() OVER (ORDER BY salary DESC) AS global_rank  
FROM  
 employees;

**実行結果:**

| employee_name | salary | global_rank |
| :------------ | :----- | :---------- |
| David         | 7000   | 1           |
| Bob           | 6000   | 2           |
| Alice         | 5000   | 3           |
| Charlie       | 4500   | 4           |

説明:  
PARTITION BY を省略しているため、全従業員が 1 つのグループとして扱われ、給与の高い順に ROW_NUMBER()が割り当てられています。

### **2\. ORDER BY を省略した場合**

ORDER BY 句が省略された場合、デフォルトのウィンドウフレームが適用されます。この場合、**ウィンドウフレームはパーティション内の全ての行** (RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) となります。

注意点:  
ORDER BY がないと、順序に意味を持つ関数（ROW_NUMBER(), RANK(), LAG(), LEAD()など）は非決定的な結果を返す可能性があります。集計関数（SUM(), AVG()など）の場合は、パーティション全体での集計値が各行に表示されます。  
**例: 部門ごとの給与合計を各行に表示**

employees テーブルに department 列を追加します。

**事前データ:**

employees テーブル:

| employee_id | employee_name | department | salary |
| :---------- | :------------ | :--------- | :----- |
| 1           | Alice         | HR         | 5000   |
| 2           | Bob           | Sales      | 6000   |
| 3           | Charlie       | HR         | 4500   |
| 4           | David         | Sales      | 7000   |

**SQL:**

SELECT  
 employee_name,  
 department,  
 salary,  
 SUM(salary) OVER (PARTITION BY department) AS total_department_salary  
FROM  
 employees;

**実行結果:**

| employee_name | department | salary | total_department_salary |
| :------------ | :--------- | :----- | :---------------------- |
| Alice         | HR         | 5000   | 9500                    |
| Charlie       | HR         | 4500   | 9500                    |
| Bob           | Sales      | 6000   | 13000                   |
| David         | Sales      | 7000   | 13000                   |

説明:  
ORDER BY を省略しているため、PARTITION BY department で分割された各部門内で、全ての行がフレームに含まれます。これにより、SUM(salary)は部門全体の合計給与を計算し、その結果が部門内の各従業員行に表示されています。

## **ウィンドウフレーム (Window Frame) の詳細な比較**

ORDER BY 句と組み合わせて使用し、各行の計算に含める行の**範囲**を定義します。これにより、単純な累積計算だけでなく、移動平均や期間内の最大/最小値などのより高度な分析が可能になります。

ウィンドウフレームの指定は、以下の形式で行います。

{ ROWS | RANGE | GROUPS } BETWEEN \<開始点\> AND \<終了点\>

### **フレームを構成する要素**

- **種類**:
  - **ROWS (行数ベース)**: 物理的な「行数」でフレームを定義します。
  - **RANGE (値ベース)**: ORDER BY 句で指定された列の「値の範囲」でフレームを定義します。
  - **GROUPS (順位グループベース)**: ORDER BY 句で指定された値の「同順位グループ単位」でフレームを定義します。
- **開始 / 終了**:
  - UNBOUNDED PRECEDING: パーティションの**先頭**の行/値まで
  - \<N\> PRECEDING: 現在の行から**N 行（または N 単位）前**まで
  - CURRENT ROW: **現在の行**
  - \<N\> FOLLOWING: 現在の行から**N 行（または N 単位）後**まで
  - UNBOUNDED FOLLOWING: パーティションの**末尾**の行/値まで
  - VALUE PRECEDING (RANGE のみ): ORDER BY の列値が現在の行の値から指定した VALUE 分だけ小さい範囲まで
  - VALUE FOLLOWING (RANGE のみ): ORDER BY の列値が現在の行の値から指定した VALUE 分だけ大きい範囲まで

### **デフォルトのウィンドウフレーム**

ウィンドウフレームを明示的に指定しない場合、以下のデフォルトルールが適用されます。

- **ORDER BY 句がない場合**:
  - デフォルトフレームは RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING です。
  - これはパーティション内の全ての行をフレームに含めることを意味します。
- **ORDER BY 句がある場合**:
  - デフォルトフレームは RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW です。
  - これはパーティションの最初から、ORDER BY 句で指定された値が現在の行と同じ値を持つ全ての行までをフレームに含めることを意味します。

### **ROWS, RANGE, GROUPS の具体的な比較例**

各フレームタイプの挙動を理解するため、以下の sales_data テーブルを使って違いを確認しましょう。特に、同じ amount 値を持つ行が含まれている点に注目してください。

**事前データ:**

sales_data テーブル:

| id  | sale_date    | amount |
| :-- | :----------- | :----- |
| 1   | '2023-01-01' | 100    |
| 2   | '2023-01-02' | 120    |
| 3   | '2023-01-02' | 120    |
| 4   | '2023-01-03' | 110    |
| 5   | '2023-01-04' | 150    |
| 6   | '2023-01-04' | 130    |
| 7   | '2023-01-05' | 140    |

SQL (3 種類フレームの比較):  
このクエリでは、結果の視認性を高めるため、外側の ORDER BY 句を amount, id としています。各ウィンドウ関数の OVER 句内の ORDER BY はそれぞれのフレームタイプに最適なものを選択しています。  
SELECT  
 id,  
 sale_date,  
 amount,  
 \-- (A) ROWS: 物理的な行数でフレームを定義 (現在の行と過去 2 行)  
 \-- OVER 句の ORDER BY は sale_date, id で固定し、物理的な行順を明確にする  
 AVG(amount) OVER (  
 ORDER BY sale_date, id  
 ROWS BETWEEN 2 PRECEDING AND CURRENT ROW  
 ) AS avg_rows_3_preceding,

    \-- (B) RANGE: ORDER BY amount の値の範囲でフレームを定義 (UNBOUNDED PRECEDING から CURRENT ROW のamount値まで)
    \-- 同一amount値の行はすべてフレームに含まれることに注目
    AVG(amount) OVER (
        ORDER BY amount
        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS avg\_range\_by\_amount\_cumulative,

    \-- (C) GROUPS: ORDER BY amount の同順位グループ単位でフレームを定義 (現在のグループとその前の1グループ)
    \-- ORDER BY amount で、amountの同順位グループを1単位としてフレームに含めることに注目
    AVG(amount) OVER (
        ORDER BY amount
        GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW
    ) AS avg\_groups\_1\_preceding\_by\_amount

FROM  
 sales_data  
ORDER BY  
 amount, id; \-- 結果の表示順は amount, id でソートして、フレームの挙動を確認しやすくする

**実行結果 (上記 SQL の ORDER BY amount, id 順にソート):**

| id  | sale_date  | amount | avg_rows_3_preceding | avg_range_by_amount_cumulative | avg_groups_1_preceding_by_amount |
| :-- | :--------- | :----- | :------------------- | :----------------------------- | :------------------------------- |
| 1   | 2023-01-01 | 100    | 100.0                | 100.0                          | 100.0                            |
| 4   | 2023-01-03 | 110    | 116.67               | 105.0                          | 105.0                            |
| 2   | 2023-01-02 | 120    | 110.0                | 112.5                          | 116.67                           |
| 3   | 2023-01-02 | 120    | 113.33               | 112.5                          | 116.67                           |
| 6   | 2023-01-04 | 130    | 130.0                | 116.0                          | 123.33                           |
| 7   | 2023-01-05 | 140    | 140.0                | 120.0                          | 135.0                            |
| 5   | 2023-01-04 | 150    | 126.67               | 124.28                         | 145.0                            |

**各フレームの解説:**

- **(A) avg_rows_3_preceding (ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)**
  - OVER 句は ORDER BY sale_date, id で、物理的な行順が定義されています。
  - **フレーム**: 現在の行と、その物理的に前の 2 行（合計 3 行）です。
  - **例 1**: id=3, amount=120 (sale_date='2023-01-02') の行の場合:
    - フレームは、現在の行（id=3）と、sale_date, id 順で前の 2 行（id=1, id=2）の合計 3 行です。
    - 対象となる amount: (100 (id=1), 120 (id=2), 120 (id=3))
    - 平均: (100 \+ 120 \+ 120\) / 3 \= 113.33。
  - **例 2**: id=4, amount=110 (sale_date='2023-01-03') の行の場合:
    - フレームは、現在の行（id=4）と、sale_date, id 順で前の 2 行（id=2, id=3）の合計 3 行です。
    - 対象となる amount: (120 (id=2), 120 (id=3), 110 (id=4))
    - 平均: (120 \+ 120 \+ 110\) / 3 \= 116.67。
  - **特徴**: 物理的な行数で範囲を厳密に区切るため、同順位の値があっても個々の行として数えます。移動平均などで直感的に理解しやすいです。
- **(B) avg_range_by_amount_cumulative (RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)**
  - OVER 句は ORDER BY amount です。
  - **フレーム**: amount が無限以前から**現在の行の amount 値と同じかそれよりも小さい**値を持つ全ての行です。
  - **例 1**: id=1, amount=100 の行の場合:
    - フレームは、amount \<= 100 の行すべてです。
    - 対象となる amount: (100 (id=1))
    - 平均: 100 / 1 \= 100.0。
  - **例 2**: id=4, amount=110 の行の場合:
    - フレームは、amount \<= 110 の行すべてです。
    - 対象となる amount: (100 (id=1), 110 (id=4))
    - 平均: (100 \+ 110\) / 2 \= 105.0。
  - **例 3**: id=2, amount=120 および id=3, amount=120 の行の場合:
    - フレームは、amount \<= 120 の行すべてです。
    - 対象となる amount: (100 (id=1), 110 (id=4), 120 (id=2), 120 (id=3))
    - 平均: (100 \+ 110 \+ 120 \+ 120\) / 4 \= 112.5。
  - **特徴**: ORDER BY 句で指定した値が同じ行はフレームに自動的に含まれます。日付範囲での集計や、同順位の値をまとめて扱いたい場合に強力です。
- **(C) avg_groups_1_preceding_by_amount (GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW)**
  - OVER 句は ORDER BY amount です。
  - **フレーム**: ORDER BY 列の**同順位グループ単位**で定義されます。現在の行が属する同順位グループと、その物理的に 1 つ前の同順位グループです。
  - まず、amount による順位グループを考えます:
    - G1: amount=100 (id=1)
    - G2: amount=110 (id=4)
    - G3: amount=120 (id=2, 3\)
    - G4: amount=130 (id=6)
    - G5: amount=140 (id=7)
    - G6: amount=150 (id=5)
  - **例 1**: id=1, amount=100 の行の場合:
    - フレームは、現在のグループ（G1）のみです。
    - 対象となる amount: (100 (id=1))
    - 平均: 100 / 1 \= 100.0。
  - **例 2**: id=4, amount=110 の行の場合:
    - フレームは、現在のグループ（G2）と、その前のグループ（G1）です。
    - 対象となる amount: (100 (id=1), 110 (id=4))
    - 平均: (100 \+ 110\) / 2 \= 105.0。
  - **例 3**: id=2, amount=120 および id=3, amount=120 の行の場合:
    - フレームは、現在のグループ（G3）と、その前のグループ（G2）です。
    - 対象となる amount: (110 (id=4), 120 (id=2), 120 (id=3))
    - 平均: (110 \+ 120 \+ 120\) / 3 \= 116.67。
  - **特徴**: 同順位のグループを 1 単位として扱うため、ランキングと組み合わせて特定の順位範囲の集計を行いたい場合に便利です。

### **ROWS, RANGE, GROUPS の使い分けのポイント**

| フレームの種類 | 集計範囲の基準                | 主な用途と特徴                                                                                                                                                                                 |
| :------------- | :---------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ROWS**       | 物理的な行数                  | \- 直近 N 件のデータなど、**厳密な行数**で範囲を区切りたい場合。\<br\>- 同順位の値があっても、物理的な行位置で区切る。\<br\>- 移動平均、移動合計、LAG/LEAD と組み合わせて頻繁に使用。          |
| **RANGE**      | ORDER BY の値の範囲           | \- 日付や数値の**連続する値の範囲**で区切りたい場合。\<br\>- ORDER BY 列の値が同じ行は**全てフレームに含まれる**。\<br\>- 時系列データの期間ベース集計（例: 過去 30 日間の売上）に非常に強力。 |
| **GROUPS**     | ORDER BY の同順位グループ単位 | \- ORDER BY 列の**同順位グループ**を 1 単位として範囲を区切りたい場合。\<br\>- ランキングと組み合わせて、論理的な順位グループに基づいた集計に便利。                                            |

## **ウィンドウ関数 (Window Functions)**

### **ランキング関数 (Ranking Functions)**

特定のパーティション内での順位を決定します。

#### **ROW_NUMBER(): 連番 (実務での重要度：高)**

各パーティション内で、ORDER BY 句で指定された順序に基づき、**重複を考慮せず**に 1 からのユニークな連番を付与します。

**例:** 各カテゴリ内で、価格が高い順に商品に連番を付与。

事前データ:  
products テーブルを再利用します。  
**SQL:**

SELECT  
 product_name,  
 price,  
 category,  
 ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) AS rank_by_price_in_category  
FROM  
 products  
ORDER BY  
 category, rank_by_price_in_category;

**実行結果:**

| product_name | price   | category    | rank_by_price_in_category |
| :----------- | :------ | :---------- | :------------------------ |
| Laptop       | 1200.00 | Electronics | 1                         |
| Keyboard     | 75.00   | Electronics | 2                         |
| Mouse        | 25.50   | Electronics | 3                         |
| Headset      | 150.00  | Peripherals | 1                         |
| Webcam       | 50.00   | Peripherals | 2                         |
| Monitor      | 300.00  | NULL        | 1                         |
| (NULL)       | 10.00   | Peripherals | 3                         |

#### **RANK() / DENSE_RANK(): 順位付け (実務での重要度：中)**

- **RANK()**: 同じ値の行には同じ順位を付与し、次の異なる値の順位は、同順位の数を飛ばして付けられます。
- **DENSE_RANK()**: 同じ値の行には同じ順位を付与し、次の異なる値の順位は、同順位の数を飛ばさずに連続して付けられます。

**例:** 価格の同順位を考慮したランキング。

**事前データ:**

scores テーブル:

| student_id | score |
| :--------- | :---- |
| 1          | 90    |
| 2          | 85    |
| 3          | 90    |
| 4          | 70    |
| 5          | 85    |

**SQL:**

SELECT  
 student_id,  
 score,  
 RANK() OVER (ORDER BY score DESC) AS rank_score,  
 DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank_score  
FROM  
 scores  
ORDER BY  
 score DESC, student_id;

**実行結果:**

| student_id | score | rank_score | dense_rank_score |
| :--------- | :---- | :--------- | :--------------- |
| 1          | 90    | 1          | 1                |
| 3          | 90    | 1          | 1                |
| 2          | 85    | 3          | 2                |
| 5          | 85    | 3          | 2                |
| 4          | 70    | 5          | 3                |

**説明:**

- RANK()では、90 点の 2 人が 1 位の後に、85 点の 2 人は 3 位（2 位が飛ばされる）となります。
- DENSE_RANK()では、90 点の 2 人が 1 位の後に、85 点の 2 人は 2 位（順位が詰まる）となります。

#### **NTILE(N): グループ分けランキング (実務での重要度：中)**

NTILE(N)関数は、ORDER BY 句で指定された順序に基づいて、行を N 個のほぼ等しいグループに分割し、それぞれの行に 1 から N までのグループ番号を割り当てます。グループ内の行数はできるだけ均等になるように調整されます。

**例:** 各カテゴリ内で、価格に基づいて商品を 3 つのティア（高額、中額、低額）に分類。

事前データ:  
products テーブルを再利用します。  
**SQL:**

SELECT  
 product_name,  
 price,  
 category,  
 NTILE(3) OVER (PARTITION BY category ORDER BY price DESC) AS price_tier  
FROM  
 products  
WHERE category IS NOT NULL  
ORDER BY  
 category, price_tier, price DESC;

**実行結果:**

| product_name | price   | category    | price_tier |
| :----------- | :------ | :---------- | :--------- |
| Laptop       | 1200.00 | Electronics | 1          |
| Keyboard     | 75.00   | Electronics | 2          |
| Mouse        | 25.50   | Electronics | 3          |
| Headset      | 150.00  | Peripherals | 1          |
| Webcam       | 50.00   | Peripherals | 2          |
| (NULL)       | 10.00   | Peripherals | 3          |

説明:  
Electronics カテゴリの商品は 3 つあるので、それぞれ 1, 2, 3 のティアに割り当てられます。Peripherals カテゴリも 3 つなので同様です。もし行数が N で割り切れない場合、最初のグループから順に多くの行が割り当てられます。

### **値ベース関数 (Value-based Functions)**

ウィンドウ内の他の行の値を参照する関数です。

#### **LAG(column, offset, default) / LEAD(column, offset, default): 前後の行の値を参照 (実務での重要度：非常に高)**

- **LAG(column, offset, default)**: 現在の行から offset で指定された数だけ前の行の column の値を返します。前の行がない場合は default で指定された値を返します（デフォルトは NULL）。
- **LEAD(column, offset, default)**: 現在の行から offset で指定された数だけ後の行の column の値を返します。後の行がない場合は default で指定された値を返します（デフォルトは NULL）。

**例: 日次売上の前日比を計算**

**事前データ:**

daily_sales テーブル:

| sale_date    | amount |
| :----------- | :----- |
| '2023-01-01' | 100    |
| '2023-01-02' | 120    |
| '2023-01-03' | 110    |
| '2023-01-04' | 150    |
| '2023-01-05' | 130    |

**SQL:**

SELECT  
 sale_date,  
 amount,  
 LAG(amount, 1, 0\) OVER (ORDER BY sale_date) AS previous_day_amount, \-- 1 日前の売上 (前の行がない場合は 0)  
 amount \- LAG(amount, 1, 0\) OVER (ORDER BY sale_date) AS daily_diff \-- 前日比  
FROM  
 daily_sales  
ORDER BY  
 sale_date;

**実行結果:**

| sale_date  | amount | previous_day_amount | daily_diff |
| :--------- | :----- | :------------------ | :--------- |
| 2023-01-01 | 100    | 0                   | 100        |
| 2023-01-02 | 120    | 100                 | 20         |
| 2023-01-03 | 110    | 120                 | \-10       |
| 2023-01-04 | 150    | 110                 | 40         |
| 2023-01-05 | 130    | 150                 | \-20       |

説明:  
LAG(amount, 1, 0)は、現在の行の amount の 1 つ前の行の amount を取得します。最初の行には前の行がないため、デフォルト値の 0 が使われます。これにより、前日比を計算できます。

#### **FIRST_VALUE(column) / LAST_VALUE(column): ウィンドウ内の最初/最後の値 (実務での重要度：中)**

- **FIRST_VALUE(column)**: 現在のウィンドウフレーム内の最初の行の column の値を返します。
- **LAST_VALUE(column)**: 現在のウィンドウフレーム内の最後の行の column の値を返します。

これらの関数はウィンドウフレームの定義に大きく影響されます。特に LAST_VALUE はデフォルトのフレーム（RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW）では現在の行までしか見ないため、期待通りの結果を得るにはフレーム指定が重要です。

**例:** 各顧客の最初の注文日と最後の注文日を、各注文行に表示。

事前データ:  
orders テーブルを再利用します。  
**SQL:**

SELECT  
 customer_id,  
 order_date,  
 amount,  
 FIRST_VALUE(order_date) OVER (PARTITION BY customer_id ORDER BY order_date) AS first_order_date,  
 LAST_VALUE(order_date) OVER (PARTITION BY customer_id ORDER BY order_date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_order_date  
FROM  
 orders  
ORDER BY  
 customer_id, order_date;

**実行結果:**

| customer_id | order_date | amount | first_order_date | last_order_date |
| :---------- | :--------- | :----- | :--------------- | :-------------- |
| 1           | 2023-01-01 | 100    | 2023-01-01       | 2023-01-10      |
| 1           | 2023-01-05 | 150    | 2023-01-01       | 2023-01-10      |
| 1           | 2023-01-10 | 200    | 2023-01-01       | 2023-01-10      |
| 2           | 2023-01-01 | 50     | 2023-01-01       | 2023-01-07      |
| 2           | 2023-01-07 | 70     | 2023-01-01       | 2023-01-07      |

説明:  
FIRST_VALUE は、customer_id パーティション内で最も早い order_date を返します。  
LAST_VALUE は、デフォルトのウィンドウフレームではうまくいかないため、ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING と明示的にフレームを指定し、パーティション全体の最後の order_date を取得しています。

#### **NTH_VALUE(column, N): N 番目の値 (実務での重要度：低)**

現在のウィンドウフレーム内の N 番目の行の column の値を返します。

**例:** 各カテゴリ内で、2 番目に価格が高い商品名を取得。

事前データ:  
products テーブルを再利用します。  
**SQL:**

SELECT  
 product_name,  
 price,  
 category,  
 NTH_VALUE(product_name, 2\) OVER (PARTITION BY category ORDER BY price DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS second_highest_price_product  
FROM  
 products  
WHERE category IS NOT NULL  
ORDER BY  
 category, price DESC;

**実行結果:**

| product_name | price   | category    | second_highest_price_product |
| :----------- | :------ | :---------- | :--------------------------- |
| Laptop       | 1200.00 | Electronics | Keyboard                     |
| Keyboard     | 75.00   | Electronics | Keyboard                     |
| Mouse        | 25.50   | Electronics | Keyboard                     |
| Headset      | 150.00  | Peripherals | Webcam                       |
| Webcam       | 50.00   | Peripherals | Webcam                       |
| (NULL)       | 10.00   | Peripherals | Webcam                       |

説明:  
PARTITION BY category でカテゴリごとに区切り、ORDER BY price DESC で価格が高い順に並べます。NTH_VALUE(product_name, 2)とウィンドウフレームを指定することで、各カテゴリの 2 番目に価格が高い商品の product_name を取得しています。

### **集計ウィンドウ (Aggregate Window Functions) (実務での重要度：非常に高)**

SUM(), AVG(), COUNT(), MIN(), MAX()などの集計関数を OVER()句と共に使用することで、グループ内の集計値を各行に表示できます。

#### **例: 各商品のカテゴリ内での合計価格と平均価格を算出**

事前データ:  
products テーブルを再利用します。  
**SQL:**

SELECT  
 product_name,  
 price,  
 category,  
 SUM(price) OVER (PARTITION BY category) AS total_price_in_category,  
 AVG(price) OVER (PARTITION BY category) AS avg_price_in_category  
FROM  
 products  
ORDER BY  
 category, product_name;

**実行結果:**

| product_name | price   | category    | total_price_in_category | avg_price_in_category |
| :----------- | :------ | :---------- | :---------------------- | :-------------------- |
| Keyboard     | 75.00   | Electronics | 1300.50                 | 433.50                |
| Laptop       | 1200.00 | Electronics | 1300.50                 | 433.50                |
| Mouse        | 25.50   | Electronics | 1300.50                 | 433.50                |
| Headset      | 150.00  | Peripherals | 210.00                  | 70.00                 |
| Webcam       | 50.00   | Peripherals | 210.00                  | 70.00                 |
| (NULL)       | 10.00   | Peripherals | 210.00                  | 70.00                 |
| Monitor      | 300.00  | NULL        | 300.00                  | 300.00                |

説明:  
SUM(price) OVER (PARTITION BY category) は、category で区切られたグループ内での price の合計を計算し、その結果を各行に表示します。GROUP BY とは異なり、行の数は減りません。

#### **💡 実務で頻出のシナリオ: 累計売上 (Running Total)**

BI ツールやレポート作成で非常によく使われるのが、時系列データにおける累計値の計算です。

**例: 顧客ごとの注文の累計購入額**

**事前データ:**

orders テーブル:

| order_id | customer_id | order_date   | amount |
| :------- | :---------- | :----------- | :----- |
| 101      | 1           | '2023-01-01' | 100    |
| 102      | 2           | '2023-01-01' | 50     |
| 103      | 1           | '2023-01-05' | 150    |
| 104      | 2           | '2023-01-07' | 70     |
| 105      | 1           | '2023-01-10' | 200    |

**SQL:**

SELECT  
 customer_id,  
 order_date,  
 amount,  
 SUM(amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS cumulative_amount  
FROM  
 orders  
ORDER BY  
 customer_id, order_date;

**実行結果:**

| customer_id | order_date | amount | cumulative_amount |
| :---------- | :--------- | :----- | :---------------- |
| 1           | 2023-01-01 | 100    | 100               |
| 1           | 2023-01-05 | 150    | 250               |
| 1           | 2023-01-10 | 200    | 450               |
| 2           | 2023-01-01 | 50     | 50                |
| 2           | 2023-01-07 | 70     | 120               |

説明:  
PARTITION BY customer_id で顧客ごとに区切り、ORDER BY order_date で注文日順に並べます。SUM(amount) OVER (...)は、各顧客の、その時点までの注文金額の合計（累計）を計算します。

### **移動平均 (Moving Average) (実務での重要度：高)**

時系列データにおいて、特定期間（ウィンドウフレーム）内の平均値を計算し、各時点でのトレンドを滑らかにする分析手法です。

#### **例: 日次売上の 3 日間移動平均**

**事前データ:**

daily_sales テーブル:

| sale_date    | amount |
| :----------- | :----- |
| '2023-01-01' | 100    |
| '2023-01-02' | 120    |
| '2023-01-03' | 110    |
| '2023-01-04' | 150    |
| '2023-01-05' | 130    |
| '2023-01-06' | 140    |

**SQL:**

SELECT  
 sale_date,  
 amount,  
 AVG(amount) OVER (  
 ORDER BY sale_date  
 ROWS BETWEEN 2 PRECEDING AND CURRENT ROW \-- 現在の行と過去 2 行（合計 3 日間）  
 ) AS three_day_moving_avg  
FROM  
 daily_sales  
ORDER BY  
 sale_date;

**実行結果:**

| sale_date  | amount | three_day_moving_avg |
| :--------- | :----- | :------------------- |
| 2023-01-01 | 100    | 100.0                |
| 2023-01-02 | 120    | 110.0                |
| 2023-01-03 | 110    | 110.0                |
| 2023-01-04 | 150    | 126.66666666666667   |
| 2023-01-05 | 130    | 130.0                |
| 2023-01-06 | 140    | 140.0                |

**説明:**

- ROWS BETWEEN 2 PRECEDING AND CURRENT ROW は、現在の行と、その前の 2 行（合計 3 行）をウィンドウフレームとして指定します。
- 例えば、'2023-01-03' の移動平均は (100 \+ 120 \+ 110\) / 3 \= 110.0 となります。
- ウィンドウフレームを省略した場合、デフォルトで RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW となり、パーティションの最初から現在の行までの累積値が計算されます。  
  💡\*\*「直近 N 件の平均」を計算する際も、この ROWS BETWEEN 句を使ってウィンドウフレームを調整します。例えば、直近 5 件の平均であれば ROWS BETWEEN 4 PRECEDING AND CURRENT ROW となります。\*\*

#### **💡 コラム: GROUP BY とウィンドウ関数の違い**

| 特徴               | GROUP BY 句                                       | ウィンドウ関数 (OVER())                                    |
| :----------------- | :------------------------------------------------ | :--------------------------------------------------------- |
| **行の数**         | 集約によって行数が**減る**（グループごとに 1 行） | 元の行数を**維持**したまま各行に結果を付加                 |
| **集計のスコープ** | 全テーブルまたは WHERE 句で絞り込まれた行全体     | PARTITION BY で定義された論理的なグループ（ウィンドウ）内  |
| **利用場所**       | SELECT 句、HAVING 句 (GROUP BY とセット)          | SELECT 句、ORDER BY 句                                     |
| **結果の利用方法** | グループ単位での集計結果のみ                      | 個々の行のコンテキストで集計結果やランキングなどを利用可能 |

実務では、全体の集計値が必要な場合は GROUP BY、各行の隣接するデータやグループ内での相対的な情報が必要な場合はウィンドウ関数と使い分けます。

## **RDBMS 間の違いに注意！ (実務での重要度：中)**

ウィンドウ関数は多くの RDBMS で標準的にサポートされていますが、細かい構文や挙動、パフォーマンス特性には差異があります。

| 機能/概念                  | PostgreSQL              | MySQL                  | Oracle       | SQL Server   |
| :------------------------- | :---------------------- | :--------------------- | :----------- | :----------- |
| ウィンドウ関数             | 標準サポート            | 8.0 以降で標準サポート | 標準サポート | 標準サポート |
| ROWS BETWEEN の挙動        | 標準的                  | 標準的                 | 標準的       | 標準的       |
| RANGE BETWEEN の挙動       | 標準的                  | 標準的                 | 標準的       | 標準的       |
| GROUPS BETWEEN の挙動      | 標準的                  | サポートなし           | サポートなし | サポートなし |
| NTILE()                    | 標準サポート            | 標準サポート           | 標準サポート | 標準サポート |
| LAG()/LEAD()               | 標準サポート            | 標準サポート           | 標準サポート | 標準サポート |
| FIRST_VALUE()/LAST_VALUE() | 標準サポート            | 標準サポート           | 標準サポート | 標準サポート |
| NTH_VALUE()                | 標準サポート            | 標準サポート           | 標準サポート | 標準サポート |
| FILTER 句 (集計関数)       | PostgreSQL のみサポート | サポートなし           | サポートなし | サポートなし |

特に、MySQL では古いバージョンでウィンドウ関数がサポートされていなかったため、バージョンの確認が必要です。GROUPS BETWEEN 句は PostgreSQL で導入された比較的新しい機能であり、他の RDBMS では未サポートの場合が多いです。

実務で特定の RDBMS を使用する際は、必ずその RDBMS の公式ドキュメントを確認するようにしましょう。

これで、SQL 基礎の「ウィンドウ関数の詳細」に関する講義資料は終わりです。  
他に知りたいことがあれば、お気軽にお尋ねください。
