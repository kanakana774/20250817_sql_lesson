# **SQL 基礎：集計とグループ化、関数**

## **導入：集計とグループ化の目的**

データベースに格納されている生データは、そのままでは大量すぎて全体像を把握しにくい場合があります。ビジネスにおける意思決定や分析には、データを要約し、傾向を把握することが不可欠です。ここで「集計」と「グループ化」の概念が重要になります。

- **集計**: 複数の行のデータを計算し、単一の要約値を導き出すこと（例: 合計、平均、最大値）。
- **グループ化**: 特定の基準に基づいてデータを複数のグループに分割し、それぞれのグループに対して集計を行うこと。

また、日付や文字列のデータは、そのままの形式では分析や表示に適さない場合があります。これらのデータを加工・整形するために「日付・文字列関数」を活用します。

## **集計関数 (Aggregate Functions)**

集計関数は、複数の行の値をまとめて計算し、1 つの結果値を返します。SELECT 句で直接使用することも、GROUP BY 句と組み合わせて使用することもできます。

### **COUNT()：行数のカウント**

指定した行または非 NULL 値の数をカウントします。

- **COUNT(\*)**: テーブルまたはクエリ結果の**全行数**をカウントします。NULL 値を含む全ての行が対象です。
- **COUNT(列名)**: 指定した列の\*\*NULL ではない値\*\*の数をカウントします。
- **COUNT(DISTINCT 列名)**: 指定した列の**重複を除いた NULL ではない値**の数をカウントします。

例: products テーブルを仮定します。  
（product_id, product_name, price, stock_quantity, category）

```SQL
-- テーブル全体の行数をカウント
SELECT COUNT(*) AS total_products FROM products;
```

```SQL
-- price 列に値がある商品の数をカウント (NULL ではない商品の数)
SELECT COUNT(price) AS products_with_price FROM products;
```

```SQL
-- 重複を除いたカテゴリの数をカウント
SELECT COUNT(DISTINCT category) AS unique_categories FROM products;
```

#### **💡 コラム: COUNT(1) と COUNT(\*) の違い**

SQL の初心者からよく聞かれる質問ですが、PostgreSQL を含む多くの RDBMS において、COUNT(1)と COUNT(\*)の機能的な違いは**ありません**。どちらもテーブルの全行数をカウントします。

歴史的には COUNT(\*)よりも COUNT(1)の方が高速であるという誤解がありましたが、現代の RDBMS ではオプティマイザが賢いため、ほとんどの場合パフォーマンスに差はありません。どちらを使っても構いませんが、COUNT(\*)の方が SQL 標準であり、より直感的で一般的です。

### **SUM()：合計値の算出**

指定した数値列の合計値を算出します。NULL 値は無視されます。

```SQL
-- 全商品の合計価格を算出
SELECT SUM(price) AS total_price FROM products;
```

```SQL
-- 全商品の合計在庫数を算出
SELECT SUM(stock_quantity) AS total_stock FROM products;
```

### **AVG()：平均値の算出**

指定した数値列の平均値を算出します。NULL 値は計算から除外されます。

```SQL
-- 全商品の平均価格を算出
SELECT AVG(price) AS average_price FROM products;
```

#### **DISTINCT と集計関数**

集計関数に DISTINCT キーワードを適用することで、重複する値を除外して集計を行うことができます。

**例:** 重複を除いたカテゴリ数を算出

```SQL
-- 全商品数 (重複値も含む)
SELECT COUNT(category) AS average_price FROM products;
```

```SQL
-- 重複を除いた全商品数＝カテゴリ数
SELECT COUNT(DISTINCT category) AS average_distinct_price FROM products;
```

### **MIN() / MAX()：最小値・最大値の算出**

指定した列の最小値または最大値を算出します。数値型だけでなく、文字列型や日付型にも適用可能です。NULL 値は無視されます。

```SQL
-- 最も安い商品の価格
SELECT MIN(price) AS min_price FROM products;
```

```SQL
-- 最も高い商品の価格
SELECT MAX(price) AS max_price FROM products;
```

```SQL
-- アルファベット順で最初に来る商品名
SELECT MIN(product_name) AS first_product_name FROM products;
```

#### **集計関数における NULL の扱い**

集計関数（SUM, AVG, MIN, MAX, COUNT(列名), COUNT(DISTINCT 列名)）は、デフォルトで\*\*NULL 値を除外して計算\*\*します。これは特に AVG で重要です。

例: 以下のデータを持つ sales テーブルを考えます。  
| sale_id | product_id | amount |  
| :------- | :---------- | :----- |  
| 1 | 101 | 100 |  
| 2 | 102 | NULL |  
| 3 | 101 | 200 |

- COUNT(\*): 3 (全行数)
- COUNT(amount): 2 (NULL を除く値の数)
- SUM(amount): 300 (100 \+ 200\)
- AVG(amount): 150 (300 / 2、NULL は分母からも除外される)

もし NULL を含む行を平均の計算に含めたい場合は、事前に COALESCE などの関数で NULL を 0 などに置き換える必要があります。

## **グループ化 (Grouping)：GROUP BY 句と HAVING 句**

集計関数は、通常、テーブル全体の要約値を計算します。しかし、特定の条件でグループ分けし、そのグループごとに集計を行いたい場合に GROUP BY 句を使用します。HAVING 句は、そのグループ化された結果に対してさらに条件を適用する際に使います。

### **GROUP BY 句：データをグループに分割**

1 つ以上の列の値に基づいて、行をグループにまとめます。SELECT 句で集計関数以外の列を指定する場合、その列は必ず GROUP BY 句にも含める必要があります。

#### **基本構文**

```SQL
SELECT 列名 1, 集計関数(列名 2)
FROM テーブル名
GROUP BY 列名 1;
```

**例:** カテゴリごとの商品数と平均価格を算出します。

```SQL
SELECT
	CATEGORY,
	COUNT(*) AS PRODUCT_COUNT,
	AVG(PRICE) AS AVERAGE_PRICE
FROM
	PRODUCTS
GROUP BY
	CATEGORY;
```

#### **GROUP BY 句の制約と SQL エラー**

SELECT 句で、集計関数を使用しない列（非集計列）を指定する場合、その非集計列は**必ず GROUP BY 句に含めなければなりません**。これは、どのグループの値を表示すべきか SQL エンジンが判断できないためです。

**例（エラーになる場合）:**

```SQL
-- ERROR: SELECT 句の'price'は GROUP BY 句に存在しないか、集計関数で囲まれていません
SELECT
	CATEGORY,
	PRICE
FROM
	PRODUCTS
GROUP BY
	CATEGORY;
```

上記のエラーは、category でグループ化しているにもかかわらず、price という個々の行に属する値を SELECT しようとしているために発生します。category ごとに price が複数存在する可能性があるため、どの price を表示すべきか一意に決まらないからです。

#### **💡 コラム: GROUP BY の緩い RDBMS (MySQL の例)**

PostgreSQL や Oracle などの多くの RDBMS は上記の GROUP BY の制約を厳格に適用しますが、MySQL の古いバージョンや特定のモードでは、SELECT 句に GROUP BY に含まれない非集計列を指定することが許されていました。その場合、そのグループ内のいずれかの値（通常は最初に見つかった値）がランダムに選ばれて表示されるため、予期しない結果を招く可能性がありました。

このような挙動は SQL 標準に準拠しておらず、混乱の元となるため、多くの RDBMS では厳格なルールが適用されます。常に\*\*SELECT 句の非集計列は GROUP BY 句に含める\*\*ように心がけましょう。

### **HAVING 句：グループ化された結果への条件**

WHERE 句が個々の行に対する条件を指定するのに対し、HAVING 句は\*\*GROUP BY によって集計された結果\*\*に対して条件を指定します。集計関数を HAVING 句の中で直接使用できます。

#### **基本構文**

```SQL
SELECT 列名 1, 集計関数(列名 2)
FROM テーブル名
GROUP BY 列名 1
HAVING 集計結果に対する条件式;
```

**例:** 平均価格が 500 より大きいカテゴリのみを抽出します。

```SQL
SELECT
	CATEGORY,
	COUNT(*) AS PRODUCT_COUNT,
	AVG(PRICE) AS AVERAGE_PRICE
FROM
	PRODUCTS
GROUP BY
	CATEGORY
HAVING
	AVG(PRICE) > 500;
```

#### **WHERE 句と HAVING 句の違い**

混同しやすいですが、両者には明確な役割の違いがあります。

| 特徴               | WHERE 句                                               | HAVING 句                                                   |
| :----------------- | :----------------------------------------------------- | :---------------------------------------------------------- |
| **評価タイミング** | GROUP BY 句の**前**に個々の行に対して評価される        | GROUP BY 句の**後**にグループ化された結果に対して評価される |
| **使用できる要素** | 元のテーブルの列 (SELECT 句で指定されていなくても良い) | 集計関数、または GROUP BY 句で指定された列                  |
| **目的**           | データを集計する前に、不要な行をフィルタリングする     | 集計された結果の中から、さらに条件でフィルタリングする      |

**処理順のイメージ:**

1. **FROM**: どのテーブルからデータを取得するか
2. **WHERE**: 個々の行をフィルタリング（ここで不要な行を減らすことで、次の集計の負荷を軽減）
3. **GROUP BY**: フィルタリングされた行をグループ化
4. **集計関数**: 各グループ内で集計を実行
5. **HAVING**: 集計結果に対してさらにフィルタリング
6. **SELECT**: 最終的に表示する列を選択
7. **ORDER BY**: 結果を並び替える
8. **LIMIT/OFFSET**: 表示件数を制限

**例:** 在庫数が 10 より多い商品のみを対象に、カテゴリごとの平均価格を算出し、その平均価格が 500 より大きいカテゴリのみを抽出。

```SQL
SELECT
	CATEGORY,
	COUNT(*) AS PRODUCT_COUNT,
	AVG(PRICE) AS AVERAGE_PRICE
FROM
	PRODUCTS
WHERE
	STOCK_QUANTITY > 10 -- (1) まず在庫が 10 より多い商品に絞り込む（集計前）
GROUP BY
	CATEGORY
HAVING
	AVG(PRICE) > 500;

-- (2) その後、絞り込んだデータで集計し、平均価格が 500 より大きいグループを抽出（集計後）
```

## **日付・文字列関数**

SQL には、日付や文字列のデータを操作・加工するための便利な関数が多数用意されています。RDBMS によって関数の名称や引数が大きく異なる場合があるため、ここでは PostgreSQL を中心に紹介し、他の RDBMS での類似機能にも言及します。

### **文字列操作関数**

#### **CONCAT：文字列の結合**

複数の文字列を結合します。PostgreSQL では||演算子も使用できます。

```SQL
-- 列と文字列リテラルを結合
SELECT CONCAT(product_name, ' (在庫数: ', stock_quantity, ')') AS product_info
FROM products;
```

```SQL
-- PostgreSQL では || 演算子も使える
SELECT product_name || ' (価格: ' || price || '円)' AS product_detail
FROM products;
```

#### **💡 コラム: CONCAT と NULL の挙動**

- **PostgreSQL**: CONCAT 関数や||演算子で NULL が含まれる場合、NULL は文字列として扱われ、結果の文字列に NULL がそのまま含まれることはありません。代わりに、NULL は実質的に無視され、非 NULL の文字列のみが結合されます。  
  SELECT 'Hello' || NULL || 'World'; \-- 結果: 'HelloWorld'  
  SELECT CONCAT('Hello', NULL, 'World'); \-- 結果: 'HelloWorld'

- **Oracle**: CONCAT 関数（Oracle の CONCAT は 2 つの引数しか取れない点に注意）や||演算子で NULL が含まれる場合、NULL は空文字のように扱われ、結合の結果に影響を与えません。  
  \-- Oracle の場合 (参考)  
  \-- SELECT 'Hello' || NULL || 'World' FROM DUAL; \-- 結果: 'HelloWorld'

- **SQL Server**: \+演算子で文字列結合を行う際、NULL が含まれると結果全体が NULL になります。CONCAT()関数を使用すれば NULL を空文字として扱います。  
  \-- SQL Server の場合 (参考)  
  \-- SELECT 'Hello' \+ NULL \+ 'World'; \-- 結果: NULL  
  \-- SELECT CONCAT('Hello', NULL, 'World'); \-- 結果: 'HelloWorld'

このように、NULL が含まれる場合の文字列結合の挙動は RDBMS によって異なるため、注意が必要です。

#### **SUBSTRING：部分文字列の抽出**

文字列の一部を抽出します。

- SUBSTRING(文字列 FROM 開始位置 FOR 長さ) (PostgreSQL 標準の記法)
- SUBSTRING(文字列, 開始位置, 長さ) (PostgreSQL/MySQL などで利用される簡略記法)

```SQL
-- 商品名の最初の 3 文字を抽出
SELECT SUBSTRING(product_name FROM 1 FOR 3\) AS short_name
FROM products;
```

#### **💡 コラム: SUBSTRING の開始位置**

SUBSTRING 関数の開始位置は、RDBMS によって 0 始まりか 1 始まりかが異なります。

- **PostgreSQL**: **1 始まり**です。
- **MySQL**: **1 始まり**です。
- **Oracle**: **1 始まり**です。
- SQL Server: 1 始まりです。  
  多くの RDBMS で 1 始まりが採用されていますが、プログラミング言語（JavaScript や Python など）では 0 始まりが一般的なため、混同しないように注意しましょう。

#### **UPPER() / LOWER()：大文字・小文字変換**

文字列を全て大文字または小文字に変換します。

```SQL
-- 商品名を全て大文字に変換
SELECT UPPER(product_name) AS upper_name FROM products;
```

```SQL
-- 商品名を全て小文字に変換
SELECT LOWER(product_name) AS lower_name FROM products;
```

#### **TRIM()：空白文字の除去**

文字列の先頭、末尾、または両端から空白文字（または指定した文字）を除去します。

- TRIM(文字列): 両端の空白を除去
- LTRIM(文字列): 先頭の空白を除去
- RTRIM(文字列): 末尾の空白を除去

```SQL
-- 列に余分な空白がある場合
SELECT TRIM(' 商品名 A ') AS trimmed_name; -- 結果: '商品名 A'
SELECT LTRIM(' 商品名 B') AS left_trimmed_name; -- 結果: '商品名 B'
SELECT RTRIM('商品名 C ') AS right_trimmed_name; -- 結果: '商品名 C'
```

```SQL
-- 特定の文字を除去 (PostgreSQL/SQL Server)
SELECT TRIM(BOTH 'x' FROM 'xxApplexx'); -- 結果: 'Apple'
```

#### **💡 コラム: TRIM と NULL の挙動**

TRIM 関数に NULL が入力された場合、結果は NULL になります。文字列関数は、通常、入力が NULL であると結果も NULL を返すという特性（Null Propagation）を持っています。

```SQL
SELECT TRIM(NULL) AS result_null; \-- 結果: NULL
```

### **日付操作関数**

日付や時刻の情報を取得したり、加工したりします。RDBMS によって関数の名称や引数が大きく異なることが多い領域です。

#### **NOW() / CURRENT_TIMESTAMP：現在日時**

現在のシステム日時を返します。

```SQL
SELECT NOW() AS current_datetime;
SELECT CURRENT_TIMESTAMP AS current_timestamp_alias;
```

#### **日付の加算・減算 (DATEADD の概念)**

PostgreSQL では、INTERVAL キーワードを使用して日付やタイムスタンプに期間を加算・減算します。

**例:** orders テーブルの order_date 列（注文日）を利用

```SQL
-- 注文日から 7 日後の発送予定日を計算
SELECT order_id, order_date, order_date + INTERVAL '7 day' AS estimated_delivery_date
FROM orders;
```

```SQL
-- 注文日から 3 ヶ月前のデータを取得
SELECT order_id, order_date
FROM orders
WHERE order_date < NOW() - INTERVAL '3 month';
```

#### **💡 コラム: DATEADD() / DATEDIFF() 関数**

DATEADD()や DATEDIFF()は、SQL Server や MySQL などの RDBMS で一般的に使われる日付関数です。PostgreSQL ではこれらの関数は直接利用できませんが、INTERVAL や日付の引き算、EXTRACT 関数を組み合わせて同等の操作が可能です。

- **DATEADD(単位, 数値, 日付)**: 指定した日付に、指定した単位で数値を加算します。
  - 例 (SQL Server): DATEADD(day, 7, GETDATE())
- **DATEDIFF(単位, 開始日付, 終了日付)**: 2 つの日付間の差分を、指定した単位で計算します。
  - 例 (SQL Server): DATEDIFF(day, '2023-10-26', '2023-10-31')

試験や他の RDBMS に触れる際にこれらの関数名を目にすることがあるため、概念として知っておくと良いでしょう。

#### **日付の差分計算 (PostgreSQL の場合)**

PostgreSQL では、日付やタイムスタンプを直接引き算することで INTERVAL 型の差分が得られます。特定の単位での差分（日数、月数など）を得るには EXTRACT や AGE()関数を使います。

```SQL
-- 2 つの日付間の日数を算出 (結果は INTERVAL 型)
SELECT (DATE '2023-10-31' - DATE '2023-10-26') AS days_difference; -- 結果: 5 days
```

```SQL
-- 日付の差分から日数を整数として取得
SELECT EXTRACT(DAY FROM (DATE '2023-10-31' - DATE '2023-10-26')) AS days_diff_int; -- 結果: 5
```

```SQL
-- AGE()関数で年齢を計算 (users テーブルに birth_date 列がある場合)
SELECT user_name, AGE(NOW(), birth_date) AS age_interval
FROM users;
-- 結果例: John | 25 years 3 months 10 days (INTERVAL 型)
```

#### **EXTRACT()：日付要素の抽出**

日付/時刻データから年、月、日、時、分、秒、曜日などの特定の部分を抽出します。

```SQL
-- 現在の日時から年、月、日を抽出
SELECT
EXTRACT(YEAR FROM NOW()) AS current_year,
EXTRACT(MONTH FROM NOW()) AS current_month,
EXTRACT(DAY FROM NOW()) AS current_day;
```

-- 誕生日から生まれた年を抽出する例 (users テーブルに birth_date 列がある場合)

```SQL
SELECT user_name, EXTRACT(YEAR FROM birth_date) AS birth_year FROM users;
```

#### **曜日抽出**

EXTRACT または TO_CHAR 関数を使用します。

```SQL
-- EXTRACT で曜日番号を抽出
SELECT EXTRACT(DOW FROM NOW()) AS day_of_week_number;
```

**EXTRACT(DOW FROM ...) の曜日番号対応表:**

| 数値 | 曜日   |
| :--- | :----- |
| 0    | 日曜日 |
| 1    | 月曜日 |
| 2    | 火曜日 |
| 3    | 水曜日 |
| 4    | 木曜日 |
| 5    | 金曜日 |
| 6    | 土曜日 |

より分かりやすい曜日名で取得するには TO_CHAR 関数が便利です。

```SQL
-- TO_CHAR で曜日名を抽出 (PostgreSQL 推奨)
-- 'Day'は曜日名 (例: 'Monday '), 'Dy'は短縮形 (例: 'Mon')
SELECT TO_CHAR(NOW(), 'Day') AS day_of_week_full;
SELECT TO_CHAR(NOW(), 'Dy') AS day_of_week_abbr;

-- 注文日の曜日名を抽出する例 (orders テーブルに order_date 列がある場合)
SELECT order_id, order_date, TO_CHAR(order_date, 'Day') AS order_day_of_week
FROM orders;
```

#### **TO_CHAR()：日付/数値の書式設定**

日付や数値を指定したフォーマットの文字列に変換します。分析結果の表示やレポート作成で非常に役立ちます。

**例:** 注文日を YYYY-MM-DD HH24:MI:SS 形式で表示

```SQL
SELECT order_id, TO_CHAR(order_date, 'YYYY-MM-DD HH24:MI:SS') AS formatted_order_datetime
FROM orders;
```

**よく使う書式指定子 (PostgreSQL):**

| 指定子 | 説明                  | 例 ('2023-10-26 14:30:05') |
| :----- | :-------------------- | :------------------------- |
| YYYY   | 4 桁の年              | 2023                       |
| MM     | 2 桁の月              | 10                         |
| DD     | 2 桁の日              | 26                         |
| HH24   | 24 時間表記の時       | 14                         |
| MI     | 2 桁の分              | 30                         |
| SS     | 2 桁の秒              | 05                         |
| Day    | 曜日名 (スペース埋め) | Thursday                   |
| Dy     | 曜日名 (短縮形)       | Thu                        |

## **RDBMS 間の違いに注意！**

この講義資料で紹介した SQL 構文や関数は多くの RDBMS で共通ですが、細かな挙動や関数名、サポート状況は製品によって異なります。

| 機能/概念             | PostgreSQL           | MySQL              | Oracle                | SQL Server                |
| :-------------------- | :------------------- | :----------------- | :-------------------- | :------------------------ |
| COUNT(1) vs COUNT(\*) | 同じ挙動             | 同じ挙動           | 同じ挙動              | 同じ挙動                  |
| GROUP BY 非集計列     | 厳格 (エラー)        | 緩い (設定による)  | 厳格 (エラー)         | 厳格 (エラー)             |
| CONCAT の NULL 結合   | NULL 無視 (文字列化) | NULL 無視          | NULL 無視             | \+は NULL、CONCAT()は無視 |
| SUBSTRING 開始位置    | 1 始まり             | 1 始まり           | 1 始まり              | 1 始まり                  |
| BOOLEAN 型サポート    | あり                 | あり               | なし (CHAR(1)で代替)  | なし (BIT で代替)         |
| 日付加算・減算        | INTERVAL             | DATE_ADD, DATE_SUB | \+/-, NUMTOYMINTERVAL | DATEADD                   |
| 日付差分計算          | EXTRACT, AGE()       | DATEDIFF           | 日付 \- 日付          | DATEDIFF                  |
| 日付書式変換          | TO_CHAR              | DATE_FORMAT        | TO_CHAR               | FORMAT / CONVERT          |

実務で特定の RDBMS を使用する際は、必ずその RDBMS の公式ドキュメントを確認するようにしましょう。
