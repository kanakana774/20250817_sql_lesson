### 集合演算子とは

集合演算子とは、複数の`SELECT`文の結果セットを、数学的な集合演算（和集合、積集合、差集合）のように結合するための SQL 構文です。これにより、異なるテーブルや同じテーブルの異なる条件の結果を組み合わせて、より複雑なデータ分析やレポート作成が可能になります。

**基本原則:**

1.  **列数の一致**: 結合するすべての`SELECT`文は、**同じ数の列**を持っている必要があります。
2.  **データ型の互換性**: 対応する列の**データ型は互換性がある**必要があります（PostgreSQL が自動的に型変換を試みる場合もありますが、非効率的になったり、意図しない結果を招く可能性があるため、可能な限り一致させるのが理想です）。
3.  **列名の採用**: 結果セットの列名は、通常、最初の`SELECT`文で指定された列名（またはエイリアス）が採用されます。

---

### 1. `UNION` および `UNION ALL` (和集合)

`UNION`は、2 つ以上の`SELECT`文の結果セットを結合し、それらの**和集合**を返します。

#### `UNION`

- **特徴**: 結合された結果から**重複する行を排除**します。重複排除のために内部的にソートまたはハッシュ処理が行われるため、`UNION ALL`よりも処理コストがかかります。
- **用途**: 複数の異なるソースからのデータを結合し、ユニークなリストを作成したい場合。

**具体例:**

架空の`customers`テーブルと`employees`テーブルがあるとします。両テーブルには`email`列があり、企業内で顧客と従業員の両方にメールを送る必要があるが、重複は避けたいとします。

**テーブル構造:**

```sql
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100) UNIQUE
);

CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100) UNIQUE
);

INSERT INTO customers (name, email) VALUES
('Alice', 'alice@example.com'),
('Bob', 'bob@example.com'),
('Charlie', 'charlie@example.com');

INSERT INTO employees (name, email) VALUES
('David', 'david@example.com'),
('Eve', 'eve@example.com'),
('Alice', 'alice@example.com'); -- 顧客と重複するメールアドレス
```

**`UNION` の使用:**

```sql
SELECT email FROM customers
UNION
SELECT email FROM employees;
```

**結果:**

```
      email
---------------------
 alice@example.com
 bob@example.com
 charlie@example.com
 david@example.com
 eve@example.com
(5 rows)
```

`alice@example.com`は`customers`と`employees`の両方に存在しますが、`UNION`により 1 つだけ返されます。

#### `UNION ALL`

- **特徴**: 結合された結果から**重複する行もすべて含めて**返します。重複排除処理がないため、`UNION`よりも高速に動作します。
- **用途**: 単純に複数の結果セットを結合したい場合や、重複が許容される場合、または重複自体が意味を持つ場合。

**具体例:**

同じ`customers`と`employees`テーブルを使用します。今回は、メールアドレスの重複もすべて含めて、全関係者へのメールリストを作成したいとします。

**`UNION ALL` の使用:**

```sql
SELECT email FROM customers
UNION ALL
SELECT email FROM employees;
```

**結果:**

```
      email
---------------------
 alice@example.com
 bob@example.com
 charlie@example.com
 david@example.com
 eve@example.com
 alice@example.com
(6 rows)
```

`alice@example.com`が 2 回現れることで、顧客としても従業員としても関係があることが示されます。

---

### 2. `INTERSECT` (積集合)

`INTERSECT`は、2 つ以上の`SELECT`文の結果セットに**両方に存在する行のみ**を返します。結果は自動的に重複が排除されます。

- **用途**: 複数のグループに共通して存在する要素（エンティティ）を見つけたい場合。

**具体例:**

顧客でもあり、従業員でもある人のメールアドレス（つまり、両方のリストに存在するメールアドレス）を見つけたい場合。

**`INTERSECT` の使用:**

```sql
SELECT email FROM customers
INTERSECT
SELECT email FROM employees;
```

**結果:**

```
      email
-------------------
 alice@example.com
(1 row)
```

`alice@example.com`は`customers`と`employees`の両方のテーブルに存在するため、結果として返されます。

---

### 3. `EXCEPT` (差集合)

`EXCEPT`は、最初の`SELECT`文の結果セットに存在し、かつ 2 番目の`SELECT`文の結果セットには存在しない行を返します。結果は自動的に重複が排除されます。

- **用途**: あるグループにのみ存在する要素を見つけたい場合（特定の条件を満たすが、別の条件は満たさないエンティティ）。

**具体例:**

従業員ではない顧客のメールアドレス（つまり、`customers`には存在するが`employees`には存在しないメールアドレス）を見つけたい場合。

**`EXCEPT` の使用:**

```sql
SELECT email FROM customers
EXCEPT
SELECT email FROM employees;
```

**結果:**

```
      email
---------------------
 bob@example.com
 charlie@example.com
(2 rows)
```

`bob@example.com`と`charlie@example.com`は`customers`テーブルには存在しますが、`employees`テーブルには存在しないため、結果として返されます。`alice@example.com`は`employees`にも存在するため除外されます。

**逆のパターン:**

従業員だが顧客ではないメールアドレスを見つける場合。

```sql
SELECT email FROM employees
EXCEPT
SELECT email FROM customers;
```

**結果:**

```
      email
-------------------
 david@example.com
 eve@example.com
(2 rows)
```

---

### 集合演算子の優先順位と括弧

複数の集合演算子を組み合わせる場合、演算子には優先順位があります。

- `INTERSECT`が最も高い優先順位です。
- `EXCEPT`と`UNION`は同じ優先順位です。

異なる優先順位を組み合わせる場合や、特定の結合順序を強制したい場合は、SQL の一般的なルールに従い、**括弧 `()`** を使用して明示的に順序を指定する必要があります。

**具体例:**

「顧客または従業員のいずれかである人全員のメールアドレスから、従業員でもある顧客のメールアドレスを除外する」という複雑なクエリを考えます。

```sql
-- 括弧なしの場合（INTERSECTが先に評価される）
-- (SELECT email FROM customers) INTERSECT (SELECT email FROM employees) が先に実行され、
-- その結果と (SELECT email FROM customers) が UNION される
SELECT email FROM customers
UNION
SELECT email FROM customers INTERSECT SELECT email FROM employees;
-- これは実質的に SELECT email FROM customers と同じ結果になる可能性が高い
```

意図した結果を得るためには、括弧で評価順序を制御します。

```sql
-- 顧客または従業員の全メールアドレス
WITH all_emails AS (
    SELECT email FROM customers
    UNION ALL -- ここはALLでも可、重複排除は最終的に行われる
    SELECT email FROM employees
),
-- 顧客でもあり従業員でもあるメールアドレス
customer_and_employee_emails AS (
    SELECT email FROM customers
    INTERSECT
    SELECT email FROM employees
)
-- 全メールアドレスから、顧客でもあり従業員でもあるメールアドレスを除外
SELECT email FROM all_emails
EXCEPT
SELECT email FROM customer_and_employee_emails;
```

**結果:**

```
      email
---------------------
 bob@example.com
 charlie@example.com
 david@example.com
 eve@example.com
(4 rows)
```

この結果は、純粋な顧客（`bob`, `charlie`）と純粋な従業員（`david`, `eve`）のメールアドレスのリストを示しています。

---

### `ORDER BY` および `LIMIT` の適用

`ORDER BY`句や`LIMIT`句は、集合演算子の**最終的な結果セット全体**に対して適用されます。各`SELECT`文の内部で`ORDER BY`や`LIMIT`を使用することも可能ですが、それはそのサブクエリの結果にのみ影響し、最終的な結合結果の順序や件数を保証するものではありません。

**具体例:**

顧客と従業員のメールアドレスを結合し、アルファベット順に並べて最初の 3 件のみを取得したい場合。

```sql
(SELECT email FROM customers
 UNION ALL
 SELECT email FROM employees)
ORDER BY email ASC
LIMIT 3;
```

**結果:**

```
      email
-------------------
 alice@example.com
 alice@example.com
 bob@example.com
(3 rows)
```

全体が結合された後でソートされ、その上位 3 件が取得されます。

---

### 集合演算子を含む SQL クエリの論理実行順序

SQL クエリは、まず個々の`SELECT`文を独立した単位として処理し、その結果を集合演算子で結合し、最後に全体の整形を行います。

**1. 個々の `SELECT` 文の処理 (サブクエリの実行)**

- クエリ内で集合演算子 (`UNION`, `INTERSECT`, `EXCEPT`) で区切られた**各`SELECT`文**が、それぞれ以下の標準的な SQL 論理実行順序に従って個別に処理されます。

  1.  **`FROM`**: 対象テーブルの指定
  2.  **`JOIN`**: テーブルの結合 (`ON`条件による結合)
  3.  **`WHERE`**: 行のフィルタリング
  4.  **`GROUP BY`**: 行のグループ化
  5.  **`HAVING`**: グループのフィルタリング
  6.  **`SELECT`**: 列の選択と式の評価（集約関数の計算もここ）
  7.  **`DISTINCT`**: 選択された行の重複排除（`SELECT DISTINCT ...` の場合）

  - **注意**: この段階での各`SELECT`文内の`ORDER BY`や`LIMIT`は、そのサブクエリの「中間結果セット」にのみ影響し、最終的な結合結果の順序や件数には影響しません。

**2. 集合演算子による中間結果セットの結合**

- 上記ステップ 1 で生成された複数の中間結果セットが、指定された集合演算子の優先順位に従って結合されます。
- **優先順位**: `INTERSECT` > (`UNION`, `EXCEPT`)
- **同じ優先順位の場合**: 左から右に評価されます。括弧 `()` を使用して優先順位を明示的に指定できます。
- 各集合演算子の動作:
- **`UNION ALL`**: すべての行を結合します（重複も含む）。
- **`UNION`**: すべての行を結合し、重複行を排除します。
- **`INTERSECT`**: すべてのサブクエリに存在する行のみを結合します（重複は排除）。
- **`EXCEPT`**: 最初のサブクエリに存在し、かつ 2 番目以降のサブクエリには存在しない行のみを結合します（重複は排除）。
- このステップで、最終的な結果セットの「内容」が決定されます。

**3. 最終的な結果セットの整形**

- 集合演算子によって結合され、生成された**最終的な結果セット全体**に対して、以下の句が適用されます。

  1.  **`ORDER BY`**: 最終的な結果セットのソート
  2.  **`LIMIT` / `OFFSET`**: ソートされた結果からの行数の制限

---

### 集合演算子の論理実行順序のまとめ図

```
+--------------------------+    +--------------------------+
|  SELECT文 A              |    |  SELECT文 B              |
|  - FROM / JOIN           |    |  - FROM / JOIN           |
|  - WHERE                 |    |  - WHERE                 |
|  - GROUP BY / HAVING     |    |  - GROUP BY / HAVING     |
|  - SELECT / DISTINCT     |    |  - SELECT / DISTINCT     |
|  (中間結果セット A)       |    |  (中間結果セット B)       |
+--------------------------+    +--------------------------+
             |                                 |
             +----------------+----------------+
                              |
                              V
              +--------------------------------+
              | 集合演算子 (UNION, INTERSECT, EXCEPT) |
              |   - (必要なら重複排除処理)     |
              +--------------------------------+
                              |
                              V
              +--------------------------------+
              |       (結合結果セット)         |
              +--------------------------------+
                              |
                              V
              +--------------------------------+
              |           ORDER BY             |
              |           LIMIT / OFFSET       |
              +--------------------------------+
                              |
                              V
              +--------------------------------+
              |        最終クエリ結果         |
              +--------------------------------+
```

この流れを理解することで、集合演算子を使った複雑なクエリの挙動を予測し、パフォーマンス上のボトルネックを特定するのに役立ちます。

---

### 1. データ型の自動変換とパフォーマンス

`UNION`などの集合演算子では、対応する列のデータ型が互換性がある場合、PostgreSQL が自動的に型変換を試みます。

**注意点:**

- **暗黙的な型変換のオーバーヘッド**: 型変換は少なからずパフォーマンスのオーバーヘッドを発生させます。特に大量のデータを扱う場合、意図しない型変換がボトルネックになることがあります。
- **予期せぬ結果**: 型変換によって予期せぬ結果や精度損失が発生する可能性があります。例えば、`TEXT`と`INTEGER`を結合した場合、`INTEGER`が`TEXT`に変換され、数値としての比較ができなくなることがあります。
- **インデックスの利用不可**: 型変換が発生する列に対して`ORDER BY`や`WHERE`句を使用した場合、インデックスが利用されず、フルスキャンになる可能性が高まります。

**対策:**

- **明示的な型キャスト**: 可能であれば、`CAST()`関数を使って明示的に型を揃えることで、意図を明確にし、予期せぬ変換を防ぎます。
  ```sql
  SELECT column_int::TEXT FROM table1
  UNION ALL
  SELECT column_text FROM table2;
  ```
- **データ型の一貫性**: 可能な限り、結合する各`SELECT`文で対応する列のデータ型を一致させるようにデータベース設計を行うのがベストです。

### 2. `ORDER BY` と `LIMIT` の適用範囲

前述の通り、`ORDER BY`と`LIMIT`は、集合演算子の**結果セット全体**に適用するには括弧で囲む必要があります。しかし、この挙動にはもう少し深い考慮点があります。

**注意点:**

- **各`SELECT`句内の`ORDER BY`と`LIMIT`は意味がない場合がある**: 例えば、`UNION ALL`の各`SELECT`句で`LIMIT`を使用しても、最終的な結果セットの合計行数を保証するものではありません。また、各`SELECT`句で`ORDER BY`を使用しても、`UNION ALL`後の結果セットの順序は保証されません。
  ```sql
  -- このLIMITは各サブクエリに適用されるが、最終結果が5行になるとは限らない
  SELECT a FROM t1 LIMIT 5
  UNION ALL
  SELECT a FROM t2 LIMIT 5;
  ```
- **パフォーマンスへの影響**: 最終結果に`ORDER BY`を適用する場合、PostgreSQL は結合されたデータ全体をソートする必要があるため、大量のデータではソート処理に時間がかかります。

**対策:**

- **目的の明確化**: `ORDER BY`と`LIMIT`をどこに適用したいのか（各サブクエリの結果か、最終結合結果か）を明確にし、それに応じて括弧を適切に使用します。
- **インデックスの活用**: 最終結果に対して`ORDER BY`を適用する場合、ソート対象の列にインデックスが貼られているとパフォーマンスが向上する可能性があります。

### 3. NULL 値の扱い

集合演算子における`NULL`値の扱いは、特に`UNION`と`EXCEPT`で重要です。

**注意点:**

- **`UNION`における重複排除**: `UNION`は重複行を排除しますが、このとき`NULL`は他の`NULL`と同じ値と見なされます。つまり、`NULL`を含む行が複数あっても、`UNION`では 1 行として扱われます。
  ```sql
  -- table1: (1, NULL), (2, 'a')
  -- table2: (1, NULL), (3, 'b')
  SELECT * FROM table1 UNION SELECT * FROM table2;
  -- 結果: (1, NULL), (2, 'a'), (3, 'b')  -- (1, NULL)の重複は排除される
  ```
- **`EXCEPT`における比較**: `EXCEPT`では、行を比較する際に`NULL`は他の`NULL`と同じと見なされます。ただし、一般的な SQL の`WHERE`句での比較（`column = NULL`が常に`FALSE`になる）とは異なるため注意が必要です。
  ```sql
  -- table1: (1, NULL), (2, 'a')
  -- table2: (1, NULL)
  SELECT * FROM table1 EXCEPT SELECT * FROM table2;
  -- 結果: (2, 'a')  -- (1, NULL)はtable1とtable2の両方にあると見なされる
  ```

**対策:**

- **`NULL`の意図的な処理**: `NULL`値がどのように扱われるかを理解し、必要であれば`COALESCE()`関数などを使って`NULL`を特定の値に置き換えることを検討します。

### 4. 列名とエイリアス

結合された結果セットの列名は、通常、最初の`SELECT`文で指定された列名が採用されます。

**注意点:**

- **混乱の可能性**: 各`SELECT`文で異なる列名（エイリアス）を使用している場合、結果セットの列名がどれになるか、読み手にとっては分かりにくいことがあります。

**対策:**

- **一貫性のあるエイリアス**: 複数の`SELECT`文で同じ意味を持つ列には、同じエイリアスを使用するか、結果セットの列名が明確になるように調整します。

### 5. パフォーマンスの考慮事項（最適化）

- **`UNION` vs `UNION ALL`**: 重複排除が不要であれば、常に`UNION ALL`を使用してください。`UNION`は重複排除のために結果セット全体をソートまたはハッシュする必要があり、これが大きなパフォーマンスコストになります。
- **サブクエリの最適化**: 集合演算子の各サブクエリは独立して最適化されます。各サブクエリが効率的であるかを確認することが重要です。
- **インデックスの利用**: `WHERE`句や`ORDER BY`句がサブクエリや最終結果に適用される場合、関連する列に適切なインデックスが存在するか確認します。
- **データの分布**: 大量のデータに対して`UNION`を実行すると、一時ファイルへの書き出し（ディスクソート）が発生し、I/O 性能がボトルネックになることがあります。`work_mem`などのパラメータ調整も検討しますが、根本的なクエリの見直しが必要な場合もあります。
- **VIEW やマテリアライズドビューの活用**: 頻繁に結合される複雑な集合演算がある場合、その結果を VIEW として定義したり、更新頻度が低い場合はマテリアライズドビューとしてキャッシュすることで、パフォーマンスを向上させることができます。

### 6. 複雑な結合と可読性

複数の`UNION`や`EXCEPT`を組み合わせる場合、クエリが複雑になり、可読性が低下しがちです。

**注意点:**

- **デバッグの困難さ**: 複雑なクエリはデバッグが難しくなります。
- **意図しない結果**: 結合の優先順位の誤解などにより、意図しない結果を招くことがあります。

**対策:**

- **括弧を適切に使用**: 結合の順序を明確にするために括弧を積極的に使用します。
- **共通テーブル式 (CTE) の活用**: `WITH`句を使った CTE は、複雑なクエリをより小さな、管理しやすい論理ブロックに分割し、可読性とデバッグのしやすさを向上させます。
  ```sql
  WITH sales_2022 AS (
      SELECT product_id, amount FROM sales WHERE sales_year = 2022
  ),
  sales_2023 AS (
      SELECT product_id, amount FROM sales WHERE sales_year = 2023
  )
  SELECT product_id, SUM(amount) FROM sales_2022
  UNION ALL
  SELECT product_id, SUM(amount) FROM sales_2023
  ORDER BY product_id;
  ```
