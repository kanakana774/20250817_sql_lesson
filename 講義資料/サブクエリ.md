### サブクエリ研修教材（改訂版）

**目的:** PostgreSQL におけるサブクエリの概念、読み方、そして効果的な書き方を習得する。

**使用データ:**

**1. `employees` テーブル (従業員情報)**

| id  | name  | salary | department_id |
| --- | ----- | ------ | ------------- |
| 1   | Alice | 500000 | 1             |
| 2   | Bob   | 600000 | 1             |
| 3   | Carol | 450000 | 2             |
| 4   | David | 550000 | 2             |
| 5   | Eve   | 700000 | 3             |
| 6   | Frank | 620000 | 3             |

**2. `departments` テーブル (部署情報)**

| id  | name   |
| --- | ------ |
| 1   | 開発部 |
| 2   | 営業部 |
| 3   | 総務部 |

---

### 導入: サブクエリとは？

サブクエリ（副問い合わせ）とは、別のクエリの中に埋め込まれたクエリのことです。メインクエリの**条件**、**FROM 句（データソース）**、**SELECT 句（表示項目）**などに、別のクエリの結果を利用したい場合に用います。

### 1. サブクエリの正確な読み方: 論理実行順

SQL の論理実行順序を理解することは、サブクエリを含んだ複雑なクエリを正確に読み解く上で非常に重要です。

1.  `FROM`句 (`JOIN`含む)
2.  `WHERE`句
3.  `GROUP BY`句
4.  `HAVING`句
5.  `SELECT`句
6.  `DISTINCT`
7.  `ORDER BY`句
8.  `LIMIT` / `OFFSET`

サブクエリは、その**配置場所**によって論理実行順の中で評価されるタイミングが異なります。

- **FROM 句のサブクエリ (派生テーブル):** 最も早く評価され、一時的なテーブルとして扱われます。
- **WHERE 句のサブクエリ:** WHERE 句が評価される段階で、その条件を満たすためにサブクエリが実行されます。
- **SELECT 句のサブクエリ (スカラサブクエリ):** SELECT 句が評価される段階で、各行に対して実行されることがあります。

---

### 2. サブクエリを最初から書く際の思考プロセス（5 ステップ）

サブクエリを効果的に書くためには、明確な思考手順を持つことが重要です。

**サブクエリ設計の 5 ステップ:**

1.  **目的（出したい結果）を言語化する:** 最終的にどのようなデータが欲しいのかを明確にします。
2.  **それに必要な「中間データ」を洗い出す:** 目的達成のために、メインクエリの条件や FROM 句で利用したい「準備データ」を特定します。
3.  **中間データを作るクエリをサブクエリとして定義する:** 洗い出した中間データを取得する SQL クエリを単体で作成し、実行して結果を確認します。
4.  **サブクエリの結果をメインクエリにどう結合・比較するかを決める:** WHERE 句、FROM 句、SELECT 句のどこに配置し、どのように利用するかを決定します。
5.  **最後に出力項目と並び順を整える:** 最終的な SELECT 句と ORDER BY 句を完成させます。

💡 この「5 ステップ」を意識することで、複雑なクエリも分解して考えやすくなります。

---

#### 例: 「各部署の平均給与より高い従業員の一覧」を取得する。

**ステップ 1: 目的（出したい結果）を言語化する**

- 最終的に欲しいのは「従業員名、給与、所属部署名」で、条件は「その従業員の給与が、所属部署の平均給与より高いこと」。
- **最終的にイメージする結果:**
  | employee_name | salary | department_name |
  |---------------|--------|-----------------|
  | Bob | 600000 | 開発部 |
  | David | 550000 | 営業部 |
  | Eve | 700000 | 総務部 |

**ステップ 2: それに必要な「中間データ」を洗い出す**

- 「所属部署の平均給与」という情報が必要です。

**ステップ 3: 中間データを作るクエリをサブクエリとして定義する（単体で実行・確認！）**

- 部署ごとの平均給与を計算するクエリです。
- **サブクエリ単体:**
  ```sql
  SELECT
      department_id,
      AVG(salary) AS avg_salary_in_dept
  FROM
      employees
  GROUP BY
      department_id;
  ```
- **実行結果 (サンプルデータの場合):**
  | department_id | avg_salary_in_dept |
  |---------------|--------------------|
  | 1 | 550000 |
  | 2 | 500000 |
  | 3 | 660000 |

**ステップ 4: サブクエリの結果をメインクエリにどう結合・比較するかを決める**

- 今回は従業員一人ひとりの給与を、その所属部署の平均給与と比較したいので、`WHERE`句で相関サブクエリとして利用するのが自然です。または、`FROM`句で派生テーブルとして結合することも可能です。

**パターン A: WHERE 句で相関サブクエリとして利用**

- **完成したクエリ:**
  ```sql
  SELECT
      e.name AS employee_name,
      e.salary,
      d.name AS department_name
  FROM
      employees AS e
  JOIN
      departments AS d ON e.department_id = d.id
  WHERE
      e.salary > (
          SELECT
              AVG(sub_e.salary)
          FROM
              employees AS sub_e
          WHERE
              sub_e.department_id = e.department_id -- ★外側の e.department_id を参照
      );
  ```
- **実行結果:**
  | employee_name | salary | department_name |
  |---------------|--------|-----------------|
  | Bob | 600000 | 開発部 |
  | David | 550000 | 営業部 |
  | Eve | 700000 | 総務部 |

**パターン B: FROM 句で派生テーブルとして利用**

- **完成したクエリ:**
  ```sql
  SELECT
      e.name AS employee_name,
      e.salary,
      d.name AS department_name
  FROM
      employees AS e
  JOIN
      (
          SELECT -- ここが派生テーブルとなるサブクエリ
              department_id,
              AVG(salary) AS avg_salary_in_dept
          FROM
              employees
          GROUP BY
              department_id
      ) AS dept_avg ON e.department_id = dept_avg.department_id -- ★メインクエリと結合
  JOIN
      departments AS d ON e.department_id = d.id
  WHERE
      e.salary > dept_avg.avg_salary_in_dept;
  ```
- **実行結果:**
  | employee_name | salary | department_name |
  |---------------|--------|-----------------|
  | Bob | 600000 | 開発部 |
  | David | 550000 | 営業部 |
  | Eve | 700000 | 総務部 |

**ステップ 5: 最後に出力項目と並び順を整える**

- 今回はステップ 4 のクエリで最終的な SELECT 句と JOIN、WHERE 句が完成しています。必要に応じて ORDER BY 句を追加します。

---

### 3. サブクエリのパターン紹介と相関の有無

サブクエリは、その性質から大きく「非相関サブクエリ」と「相関サブクエリ」に分けられます。この違いを理解することは、パフォーマンスを考慮したクエリ作成に繋がります。

#### 3-1. 非相関サブクエリ

- **特徴:** 外側のクエリから独立して一度だけ実行されます。外側のクエリの行とは関係なく、単独で結果を算出します。
- **パフォーマンスの注意点:** 一度しか実行されないため、比較的パフォーマンスは良好です。

---

##### 例: `WHERE` 句での利用 (`IN` / `NOT IN` 句)

**ユースケース:** 特定のリストに含まれる（または含まれない）データを抽出したい場合。

**目標:** 「開発部と営業部に所属する従業員の一覧」を取得する。

- **サブクエリ単体 (非相関):**
  ```sql
  SELECT id FROM departments WHERE name IN ('開発部', '営業部');
  ```
- **実行結果:**
  | id |
  |----|
  | 1 |
  | 2 |

- **メインクエリ:**
  ```sql
  SELECT
      e.name AS employee_name,
      e.salary,
      d.name AS department_name
  FROM
      employees AS e
  JOIN
      departments AS d ON e.department_id = d.id
  WHERE
      e.department_id IN (SELECT id FROM departments WHERE name IN ('開発部', '営業部'));
  ```
- **実行結果:**
  | employee_name | salary | department_name |
  |---------------|--------|-----------------|
  | Alice | 500000 | 開発部 |
  | Bob | 600000 | 開発部 |
  | Carol | 450000 | 営業部 |
  | David | 550000 | 営業部 |

---

##### 例: `WHERE` 句での利用 (比較演算子)

**ユースケース:** 単一の値を返す非相関サブクエリと、メインクエリのカラムを比較したい場合。

**目標:** 「全従業員の平均給与より高い従業員の一覧」を取得する。

- **サブクエリ単体 (非相関):**
  ```sql
  SELECT AVG(salary) FROM employees;
  ```
- **実行結果:**
  | avg |
  |-------------------|
  | 578333.3333333334 |

- **メインクエリ:**
  ```sql
  SELECT
      name AS employee_name,
      salary
  FROM
      employees
  WHERE
      salary > (SELECT AVG(salary) FROM employees);
  ```
- **実行結果:**
  | employee_name | salary |
  |---------------|--------|
  | Bob | 600000 |
  | Eve | 700000 |
  | Frank | 620000 |

---

##### 例: `FROM` 句での利用 (派生テーブル / Derived Table)

**ユースケース:** サブクエリの結果を一時的なテーブル（ビュー）として扱い、その結果に対してさらに結合やフィルタリング、集計を行いたい場合。`FROM`句内で定義されるため、メインクエリからは独立して一度だけ実行されます。

**目標:** 「各部署の従業員数と平均給与」を計算し、さらに部署名を結合して表示する。

- **サブクエリ単体 (非相関):**
  ```sql
  SELECT
      department_id,
      COUNT(*) AS emp_count,
      AVG(salary) AS avg_salary
  FROM
      employees
  GROUP BY
      department_id;
  ```
- **実行結果:**
  | department_id | emp_count | avg_salary |
  |---------------|-----------|------------|
  | 1 | 2 | 550000 |
  | 2 | 2 | 500000 |
  | 3 | 2 | 660000 |

- **メインクエリ:**
  ```sql
  SELECT
      d.name AS department_name,
      ds.emp_count,
      ds.avg_salary
  FROM
      (
          SELECT -- ここが派生テーブルとなるサブクエリ
              department_id,
              COUNT(*) AS emp_count,
              AVG(salary) AS avg_salary
          FROM
              employees
          GROUP BY
              department_id
      ) AS ds -- ★ 派生テーブルには必ずエイリアスが必要
  JOIN
      departments AS d ON ds.department_id = d.id
  ORDER BY
      ds.avg_salary DESC;
  ```
- **実行結果:**
  | department_name | emp_count | avg_salary |
  |-----------------|-----------|------------|
  | 総務部 | 2 | 660000 |
  | 開発部 | 2 | 550000 |
  | 営業部 | 2 | 500000 |

---

#### 3-2. 相関サブクエリ

- **特徴:** 外側のクエリの**各行ごとに**サブクエリが再実行されます。外側のクエリから値を受け取り、その値を使ってサブクエリの条件を評価します。
- **パフォーマンスの注意点:** 外側の行数が増えると、その分サブクエリの実行回数が増えるため、パフォーマンスが劣化しやすい傾向があります。可能な場合は、JOIN や非相関サブクエリで代替できないか検討します。

##### 例: `WHERE` 句での利用 (`EXISTS` / `NOT EXISTS` 句)

**ユースケース:** 特定の条件を満たす関連データが存在するかどうかで、メインクエリの結果を絞り込みたい場合。

**目標:** 「給与が 600,000 円以上の従業員が一人でもいる部署の一覧」を取得する。

- **メインクエリ (EXISTS 句で相関サブクエリを利用):**
  ```sql
  SELECT
      d.name AS department_name
  FROM
      departments AS d
  WHERE
      EXISTS (
          SELECT 1
          FROM employees AS e_sub
          WHERE e_sub.department_id = d.id -- ★ 外側の d.id を参照
            AND e_sub.salary >= 600000
      );
  ```
- **実行結果:**
  | department_name |
  |-----------------|
  | 開発部 |
  | 総務部 |

  _解説: 開発部には Bob(60 万)、総務部には Eve(70 万)と Frank(62 万)がいるため、これら 2 つの部署が表示されます。_

---

##### 例: `SELECT` 句での利用 (スカラサブクエリ / Scalar Subquery)

**ユースケース:** メインクエリの各行に対して、関連する単一の値（スカラ値）を計算して表示したい場合。各行ごとに異なる値が必要なため、相関サブクエリとなることが多いです。

**目標:** 「各従業員の名前、給与、そしてその従業員が所属する部署の平均給与」を表示する。

- **メインクエリ (SELECT 句にスカラサブクエリを配置):**
  ```sql
  SELECT
      e.name AS employee_name,
      e.salary,
      d.name AS department_name,
      (
          SELECT -- ここがスカラサブクエリ (相関型)
              AVG(sub_e.salary)
          FROM
              employees AS sub_e
          WHERE
              sub_e.department_id = e.department_id -- ★ 外側の e.department_id を参照
      ) AS dept_avg_salary
  FROM
      employees AS e
  JOIN
      departments AS d ON e.department_id = d.id;
  ```
- **実行結果:**
  | employee_name | salary | department_name | dept_avg_salary |
  |---------------|--------|-----------------|-----------------|
  | Alice | 500000 | 開発部 | 550000 |
  | Bob | 600000 | 開発部 | 550000 |
  | Carol | 450000 | 営業部 | 500000 |
  | David | 550000 | 営業部 | 500000 |
  | Eve | 700000 | 総務部 | 660000 |
  | Frank | 620000 | 総務部 | 660000 |

---

### 4. `WHERE` 句と `FROM` 句でのサブクエリの違い

サブクエリ初心者が混乱しやすいポイントとして、`WHERE`句と`FROM`句でのサブクエリの使い分けがあります。これらを「テーブルを作る」か「条件を作る」かで視覚的に捉えると理解が深まります。

| 書き方                 | 処理タイミング               | 結果の扱い                 | 適する場面                     | イメージ             |
| ---------------------- | ---------------------------- | -------------------------- | ------------------------------ | -------------------- |
| **WHERE 内サブクエリ** | 各行のフィルタリング時       | 真偽値・単一値・値のリスト | 条件比較・存在チェック         | 「条件フィルタ」     |
| **FROM 内サブクエリ**  | メインクエリのテーブル作成時 | 表データ                   | 集計・中間結果を再利用したい時 | 「一時テーブル作成」 |

`FROM`句のサブクエリは、メインクエリが実行される前に、独立した一時的なテーブル（派生テーブル）として評価されます。この一時テーブルは、通常のテーブルと同様にメインクエリの`JOIN`や`WHERE`句で利用できます。

一方、`WHERE`句や`SELECT`句のサブクエリは、メインクエリの**各行が評価されるタイミング**で実行され、その行に対する条件や表示項目を決定します。相関サブクエリの場合は、この「各行が評価されるタイミングでの実行」がパフォーマンスに大きく影響します。

---

### 補足: CTE (Common Table Expression) との比較

複雑なサブクエリ、特に FROM 句のサブクエリを複数組み合わせる場合、CTE (`WITH`句) を使うとクエリの可読性を大幅に向上させることができます。CTE は、一時的な結果セットに名前を付けて定義し、その後のクエリで参照できる機能です。

```sql
-- 先ほどの「各部署の平均給与より高い従業員」のFROM句サブクエリの例をCTEで記述
WITH dept_avg AS (
    SELECT
        department_id,
        AVG(salary) AS avg_salary_in_dept
    FROM
        employees
    GROUP BY
        department_id
)
SELECT
    e.name AS employee_name,
    e.salary,
    d.name AS department_name
FROM
    employees AS e
JOIN
    dept_avg ON e.department_id = dept_avg.department_id
JOIN
    departments AS d ON e.department_id = d.id
WHERE
    e.salary > dept_avg.avg_salary_in_dept;
```

CTE を使うと、クエリの意図がより明確になり、デバッグもしやすくなります。複雑なサブクエリを書く際は、CTE の利用も検討してみましょう。
