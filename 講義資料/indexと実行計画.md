# **SQL 基礎：インデックスと実行計画**

## **導入：なぜインデックスと実行計画を学ぶのか？**

これまでの章で SQL の基本的なデータの操作方法や、複雑な分析手法を学びました。しかし、大規模なデータベースを扱う際、**クエリが期待通りの速さで実行されない**という問題に直面することがよくあります。このパフォーマンスの問題を解決し、データベースを効率的に運用するために不可欠なのが「**インデックス**」と「**実行計画**」の理解です。

- **インデックス**: データベースのテーブル内でデータを高速に検索するための仕組みで、本の索引（インデックス）のようなものです。適切に利用することで、データの検索やソート処理を劇的に改善できます。
- **実行計画**: データベース管理システム (DBMS) が SQL クエリを実行する際に、どのような手順でデータを取得・加工するかを示した計画です。これを確認することで、クエリのボトルネックを特定し、パフォーマンス改善のためのヒントを得ることができます。

本章では、これらの概念を深く掘り下げ、実践的なパフォーマンスチューニングの基礎を学びます。

## **インデックス (Indexes)**

インデックスは、データベースのパフォーマンスを向上させるための重要なツールです。テーブルの特定の列に作成され、その列の値と、その値が格納されている行の物理的な位置（またはプライマリキー）を結びつけます。これにより、DBMS はテーブル全体をスキャンすることなく、必要なデータを素早く見つけることができます。

💡**インデックスの例え**: 厚い本の特定の情報を見つけたいとき、ページの端から順に見ていく（**テーブルスキャン**）よりも、巻末の索引（**インデックス**）を使って直接ページに飛ぶ方がはるかに速い、というイメージです。

### **インデックスの作成**

インデックスは CREATE INDEX 文を使って作成します。

CREATE INDEX インデックス名 ON テーブル名 (列名 \[ASC|DESC\], ...);

### **インデックスの内部構造：B-Tree (B+Tree) 🌳**

ほとんどの RDBMS（PostgreSQL, MySQL, Oracle, SQL Server など）で使われているインデックスの主要な構造は、**B-Tree** です。PostgreSQL のデフォルトインデックスは B-Tree ですが、その内部的な実装は**B+Tree ライク**な構造を持っています。この構造を理解することが、「なぜインデックスが速いのか」「なぜ効かないパターンがあるのか」を納得する鍵となります。

B-Tree（B+Tree）は、データをソートされた状態で効率的に保存し、検索・挿入・削除を高速に行うための自己平衡型ツリー構造です。その特徴は以下の通りです。

1. **階層構造**: ルートノードから始まり、枝分かれしながらリーフノードへとたどっていきます。
2. **ソート済み**: 各ノード内のキー（インデックス列の値）は常にソートされた状態で保持されます。また、親ノードは子ノードの持つキーの範囲を示します。
3. **高速な探索**: 検索したいキーは、ルートノードから二分探索のように辿っていけば、すぐに目的のリーフノードに到達できます。データの量が増えても、探索にかかる時間は対数的にしか増えないため、非常に効率的です（例: 100 万件のデータでも数回のディスクアクセスで目的のデータを見つけられる）。
4. **リーフノード**: データの本体（テーブルの行）へのポインタ（物理アドレス、またはプライマリキー）を保持しています。B+Tree ライクな実装の場合、全てのキーとデータポインタ（またはデータ自体）がリーフノードにあり、リーフノード同士は双方向リストでつながっているため、範囲検索や順序検索も高速に行えます。

つまり、インデックスは\*\*特定の値から、それが格納されているテーブルの場所を高速に探し出すための「ソートされた地図帳」\*\*のようなものだと思ってください。

### **インデックスの種類と B-Tree の挙動**

#### **1\. 単一列インデックス (Single-Column Index)**

1 つの列に対して作成される最も基本的なインデックスです。

B-Tree の挙動:  
B-Tree のキーが 1 つの列の値で構成されます。例えば products テーブルの product_name 列にインデックスを作成した場合、B-Tree は product_name の値をキーとしてソートされた状態になります。  
**特徴**:

- 特定の 1 列のみで検索条件（WHERE 句）やソート条件（ORDER BY 句）を指定する場合に、B-Tree の高速な探索能力をフル活用できます。
- 最もシンプルで作成しやすいですが、複数の条件を組み合わせた複雑なクエリでは効果が限定されることがあります。

**例**: products テーブルの product_name 列にインデックスを作成します。

**事前データ:**

products テーブル:

| product_id | product_name | price   | stock_quantity |
| :--------- | :----------- | :------ | :------------- |
| 1          | Laptop       | 1200.00 | 50             |
| 2          | Mouse        | 25.50   | 20             |
| 3          | Keyboard     | 75.00   | 30             |
| ...        | ...          | ...     | ...            |

**SQL:**

\-- product_name 列に単一列インデックスを作成  
CREATE INDEX idx_product_name ON products (product_name);

これにより、WHERE product_name \= 'Laptop'のようなクエリは、B-Tree を辿って「Laptop」がどこにあるかを素早く見つけ、対応するテーブルの行を読み込むことで高速化されます。

#### **2\. 複合インデックス (Composite Index)**

複数の列を組み合わせて作成されるインデックスです。列の順序が非常に重要になります。

B-Tree の挙動:  
B-Tree のキーが複数の列の値の組み合わせで構成されます。これらのキーは、指定された列の順序に従って「辞書順」にソートされます。例えば、(category_id, price)という複合インデックスの場合、まず category_id でソートされ、category_id が同じであれば次に price でソートされます。  
**特徴**:

- 複数の列を AND 条件で検索する場合や、ソート条件が複数列にまたがる場合に効果的です。
- インデックスに含める列の順序（例: (A, B)と(B, A)は B-Tree のソート順が異なるため、異なるインデックス）がパフォーマンスに大きく影響します。一般的には、WHERE 句でより頻繁に絞り込む列を先頭に、次に絞り込む列を配置します。
- 複合インデックス(A, B, C)は、B-Tree の性質上、(A)、(A, B)といった\*\*先頭からの列の組み合わせ（左側プレフィックス）\*\*での検索条件でも利用されます。しかし、(B, C)や(C)のみの検索では、B-Tree の先頭キーが B や C ではないため、効率的に利用されません。これは「辞書で最初の文字しか知らないのに、真ん中の文字で探すようなもの」です。

**例**: products テーブルで category_id と price を組み合わせて検索する機会が多い場合。

**事前データ:**

products テーブル:

| product_id | product_name | price   | stock_quantity | category_id |
| :--------- | :----------- | :------ | :------------- | :---------- |
| 1          | Laptop       | 1200.00 | 50             | 1           |
| 2          | Mouse        | 25.50   | 20             | 1           |
| 3          | Keyboard     | 75.00   | 30             | 2           |
| ...        | ...          | ...     | ...            | ...         |

**SQL:**

\-- category_id と price 列の複合インデックスを作成  
\-- category_id で絞り込み、その後 price で絞り込むクエリに効果的  
CREATE INDEX idx_category_price ON products (category_id, price DESC);

これにより、WHERE category_id \= 1 AND price \> 100 のようなクエリは、まず B-Tree の category_id で 1 の範囲を探し、その中で price が 100 より大きい部分を効率的に見つけるため、高速化されます。

#### **3\. カバリングインデックス (Covering Index / Index-Only Scan)**

クエリが要求する全ての列がインデックス自体に含まれているインデックスです。DBMS はテーブル本体にアクセスすることなく、インデックスのみで必要な情報を取得できるため、I/O コストを大幅に削減し、非常に高いパフォーマンスを発揮します。

B-Tree の挙動:  
通常、B-Tree のリーフノードにはキー値とテーブル本体へのポインタが格納されます。しかし、カバリングインデックスの場合、SELECT 句で要求される追加の列もリーフノードに格納されます（PostgreSQL の INCLUDE 句はその一例です）。これにより、DBMS はインデックスの B-Tree を辿るだけで、必要な全てのデータが得られ、データが格納されているテーブル本体（ヒープ領域など）へのアクセスが不要になります。このテーブル本体へのアクセスを「ブックマークルックアップ」や「ヒープアクセス」と呼びますが、カバリングインデックスはこれを回避します。  
**特徴**:

- SELECT 句で指定する列が全てインデックスに含まれる場合に機能します。
- テーブル本体へのアクセス（ディスク I/O）がなくなるため、パフォーマンスが劇的に向上します。
- ただし、インデックスサイズが大きくなり、データ挿入・更新・削除時のオーバーヘッドが増加する可能性があります。

PostgreSQL における Index Only Scan の注意点:  
PostgreSQL で Index Only Scan が利用されるためには、インデックスがカバーする列だけでなく、対象のテーブル行が「すでに可視（visible）」である必要があります。これは、PostgreSQL の MVCC（多版型同時実行制御）の仕組み上、古いバージョンの行を参照しないことを保証するためです。  
もし VACUUM や Autovacuum が適切に動作していないと、テーブルに古い行バージョンが残り、Index Only Scan が使われず、結局テーブル本体へのアクセス（Heap Fetch）が必要になることがあります。したがって、Index Only Scan は必ずしもインデックスだけで済むわけではないことを覚えておきましょう。  
**例**: products テーブルで category_id と price を検索条件とし、product_name も結果として取得したい場合。

**SQL:**

\-- category_id をキーとし、price と product_name をインデックスに含める (PostgreSQL の INCLUDE 句の例)  
CREATE INDEX idx_category_price_name ON products (category_id) INCLUDE (price, product_name);  
\`\`\`SELECT product_name, price FROM products WHERE category_id \= 1 AND price \> 100\` のようなクエリは、このインデックスがあればテーブル本体へのアクセスなしで実行できる可能性があります。実行計画では「Index Only Scan」と表示されることが多いでしょう。

\#\#\# インデックスが効かないパターン (なぜ効かないのか？)

インデックスは万能ではありません。B-Tree の構造と探索原理を理解していれば、インデックスが利用されないパターンも納得できます。

\#\#\#\# 1\. ワイルドカード前方一致以外 (\`%\`が先頭に来る場合)

\`LIKE\`句で検索条件の先頭にワイルドカード\`%\`を使用すると、インデックスは利用されません。

\*\*SQL (インデックスが効かない):\*\*

\`\`\`sql  
\-- ワイルドカードが先頭にあるため、idx_product_name インデックスは利用されない  
SELECT product_name FROM products WHERE product_name LIKE '%Mouse%';

なぜ効かないのか:  
B-Tree はキーのソート順に基づいてデータを探索します。キーの先頭部分が分かっていれば、ツリーを辿って効率的に該当範囲を見つけることができます（例: 'Mouse%'であれば「M」から始まる範囲を探せる）。  
しかし、'%Mouse%'のように先頭がワイルドカードの場合、「M」がどこから始まるのか、あるいは「Mouse」を含む文字列がどこにあるのかを B-Tree は効率的に判断できません。これは、\*\*「巻末の索引で、単語の途中にしか分からない部分しかないのに、索引を引くことができない」\*\*のと同じ状況です。結局、DBMS はインデックスを使わず、テーブルの全行を物理的に読み込んで（シーケンシャルスキャン）、各行の product_name を一つずつチェックするしかなくなります。

**対策**:

- 可能であれば、ワイルドカードを先頭に置かない検索条件にする（例: LIKE 'Mouse%'）。
- **全文検索機能**（PostgreSQL の tsvector など）の利用を検討する。全文検索インデックスは、テキストの単語単位での検索に特化した別の構造を持っています。
- **演算子クラスの指定**（PostgreSQL）: text_pattern_ops や varchar_pattern_ops といった演算子クラスをインデックス作成時に指定することで、LIKE 'abc%'のような前方一致検索だけでなく、正規表現(\~)の先頭部分一致などのパターン検索でもインデックスを利用できるようになります。  
  \-- text_pattern_ops を指定したインデックスの例 (LIKE 'abc%' でインデックスが効く)  
  CREATE INDEX idx_product_name_pattern ON products (product_name text_pattern_ops);

  \-- しかし、'%abc' や '%abc%' の場合は依然としてインデックスは効かない

#### **2\. 列に関数を適用した場合**

WHERE 句でインデックス対象の列に何らかの関数（LOWER(), SUBSTRING(), DATE()など）を適用すると、DBMS はインデックスを利用できなくなります。

**SQL (インデックスが効かない):**

\-- product_name 列に LOWER 関数を適用しているため、idx_product_name インデックスは利用されない  
SELECT product_name FROM products WHERE LOWER(product_name) \= 'laptop';

なぜ効かないのか:  
B-Tree インデックスは、元の列の値に基づいてキーを作成し、ソートしています。  
LOWER(product_name)のように列に加工が加えられると、検索したい値'laptop'は関数が適用された結果の値であり、インデックスに格納されている元の product_name の値（例: 'Laptop', 'LAPTOP'）とは直接一致しません。  
DBMS は、検索条件 LOWER(product_name) \= 'laptop'を満たす行を探すために、テーブルの全行を読み込み、それぞれの product_name に LOWER()関数を適用し、その結果が'laptop'と一致するかどうかを確認するしかなくなります。これはインデックスの利点を完全に打ち消してしまいます。

**対策**:

- 可能であれば、関数を適用せずに検索できる形にする（例: product_name \= 'Laptop'。ただし、大文字・小文字を区別する場合は注意）。
- **関数インデックス（ファンクションインデックス）** の利用を検討する。特定の RDBMS（PostgreSQL, Oracle など）では、CREATE INDEX idx_lower_product_name ON products (LOWER(product_name));のように、関数適用後の値を基にしたインデックスを作成できます。これにより、WHERE LOWER(product_name) \= 'laptop'のようなクエリでもインデックスが利用可能になります。

#### **その他のインデックスが効かない（効きにくい）パターン**

- **データ型不一致**: 比較する列と値のデータ型が異なると、DBMS が内部的に型変換を行う必要があり、インデックスが利用されない場合があります。DBMS がインデックスキーを検索条件と比較する際、型変換が入ると、インデックスのソート順が保証されなくなるためです。
- **OR 条件**: 複数の異なる列に OR 条件を使用した場合、それぞれの条件にインデックスがあっても複合的に利用されにくいことがあります。例えば WHERE A \= 1 OR B \= 2 の場合、A と B それぞれのインデックスを別々にスキャンし、結果を結合する必要がありますが、この処理がシーケンシャルスキャンよりも高コストと判断されることがあります。
- **NOT IN / NOT EXISTS**: 否定条件は、インデックスが利用されにくい傾向があります。インデックスは「ある値が存在する場所」を特定するのに優れていますが、「ある値が存在しない場所」を特定するのは苦手です。
- **カーディナリティの低い列**: ユニークな値が非常に少ない列（例: 性別、フラグ）にインデックスを作成しても、絞り込み効果が低いため、インデックスを使うよりもテーブルスキャンの方が高速と判断されることがあります。例えば、100 万件のデータで「性別 \= '男性'」を検索する場合、50 万件の行が該当するなら、B-Tree を辿って 50 万件のポインタを取得し、50 万回のテーブルアクセスをするよりも、いっそ全件スキャンして 50 万件をフィルタリングする方が速い、とオプティマイザが判断することがあります。
- **IS NULL / IS NOT NULL**: PostgreSQL では NULL 値もインデックスに格納されます。したがって、WHERE column IS NULL や WHERE column IS NOT NULL という条件でインデックスが利用されることがあります。しかし、NULL 値の割合が多い場合（カーディナリティが低い場合）や、他の条件との組み合わせによっては、インデックススキャンよりもシーケンシャルスキャンの方が効率的と判断されることもあります。

### **インデックスのデメリット (なぜ闇雲に増やしてはいけないのか？)**

インデックスはパフォーマンス向上に貢献しますが、デメリットも存在します。これを理解せず闇雲にインデックスを増やすと、かえって性能を悪化させる原因になります。

1. 書き込み性能の低下 (Write Overhead):  
   INSERT、UPDATE、DELETE といったデータ変更操作が行われるたびに、データベースはテーブル本体だけでなく、関連する全てのインデックスも更新する必要があります。データ変更が多く発生するテーブルに多数のインデックスを作成すると、このインデックス更新のオーバーヘッドが大きくなり、結果として書き込み性能が大幅に低下します。
2. ストレージ容量の消費:  
   インデックスもデータ構造であるため、ディスク上に領域を消費します。多くのインデックスを作成すると、必要なディスク容量が増加します。
3. クエリ最適化の複雑化:  
   インデックスが増えすぎると、DBMS のオプティマイザが最適な実行計画を選択するための考慮事項が増え、かえって時間がかかったり、非効率なインデックスを選んでしまったりする可能性があります。

**💡 実務では「闇雲にインデックスを増やさず、EXPLAIN で確認して本当に必要なものだけを作る」ことが非常に重要です。**

### **その他のインデックスの種類**

#### **1\. 部分インデックス (Partial Index)**

テーブルの一部の行にのみ適用されるインデックスです。

**特徴**:

- 特定の条件を満たす行が頻繁に検索される場合に、インデックスのサイズを小さくし、更新コストを削減できます。
- 「論理削除済みを除いた検索」や「特定のフラグが true のものだけを高速化」といった実務で頻繁に発生するシナリオに非常に有効です。

**例**: users テーブルで is_active \= true のユーザーのみを対象に email 列のインデックスを作成する。

CREATE INDEX idx_active_users_email ON users (email) WHERE is_active \= true;

これにより、SELECT \* FROM users WHERE is_active \= true AND email \= 'test@example.com'のようなクエリが高速化されます。

#### **2\. ユニークインデックス (Unique Index)**

列（または列の組み合わせ）に格納される値の重複を許さないインデックスです。

**特徴**:

- データの整合性（重複の禁止）を保証する制約 (UNIQUE 制約) として機能します。
- 同時に、その列での検索を高速化するインデックスとしても機能します。
- プライマリキー（PRIMARY KEY）も内部的にはユニークインデックスとして実装されることがほとんどです。

**例**: email 列に重複を許さないインデックスを作成する。

CREATE UNIQUE INDEX idx_unique_user_email ON users (email);

UNIQUE 制約との違い:  
CREATE UNIQUE INDEX は、インデックスを作成すると同時にユニーク制約を課します。一方、ALTER TABLE ADD CONSTRAINT UNIQUE (column)のように UNIQUE 制約を明示的に追加した場合も、通常は内部的にユニークインデックスが作成されます。実務では「重複を禁止する」という目的でユニークインデックスやユニーク制約が使われることが多いです。

## **実行計画 (Execution Plan)**

実行計画は、DBMS が SQL クエリをどのように実行するかを示す「ロードマップ」です。これを確認することで、どのテーブルがどのようにスキャンされ、どのインデックスが使われ、どのように結合され、どの程度のコストがかかるかを具体的に把握できます。実行計画を分析することで、クエリのパフォーマンスボトルネックを特定し、改善策（インデックスの追加、クエリの書き換えなど）を検討するための重要な手がかりとなります。

### **EXPLAIN, EXPLAIN ANALYZE**

PostgreSQL を例に、実行計画を確認するための代表的なコマンドを紹介します。

- **EXPLAIN**:
  - クエリの**推定**実行計画を表示します。
  - 実際のクエリは実行されないため、データ量が多いテーブルに対しても安全に利用できます。
  - 計画の「**コスト (Cost)**」を推定値として表示します。コストは、処理時間とリソース使用量（特にディスク I/O と CPU サイクル）の概算値であり、**時間(ms)ではなく単位なしの相対的な比較**に用いられます。実際の実行時間とは大きくズレることが多いため、あくまで参考値として捉える必要があります。
- **EXPLAIN ANALYZE**:
  - 実際にクエリを**実行**し、その結果に基づいて実行計画を表示します。
  - 推定値に加えて、実際の実行時間 (actual time)、実際に処理された行数 (rows)、ループ回数 (loops) などの詳細な情報が表示されます。
  - より正確なパフォーマンス情報を得られるため、**実務では EXPLAIN ANALYZE で必ず実測確認する**という流れが推奨されます。ただし、クエリが長時間かかる場合や、データ変更を伴う場合は注意が必要です。

**基本構文**:

EXPLAIN \[ANALYZE\] \[VERBOSE\] \[COSTS\] \[BUFFERS\] \[TIMING\] \[SUMMARY\] SELECT ...;

**例**: products テーブルから価格が 100 より大きい商品を取得するクエリの実行計画を見る。

\-- 推定実行計画  
EXPLAIN SELECT \* FROM products WHERE price \> 100;

\-- 実際の実行計画と統計情報  
EXPLAIN ANALYZE SELECT \* FROM products WHERE price \> 100;

**実行計画の出力例 (PostgreSQL):**

\-- EXPLAIN SELECT \* FROM products WHERE price \> 100; の出力例  
Seq Scan on products (cost=0.00..15.50 rows=50 width=200)  
 Filter: (price \> 100::numeric)

\-- EXPLAIN ANALYZE SELECT \* FROM products WHERE price \> 100; の出力例  
Seq Scan on products (cost=0.00..15.50 rows=50 width=200) (actual time=0.015..0.025 rows=50 loops=1)  
 Filter: (price \> 100::numeric)  
 Planning Time: 0.088 ms  
 Execution Time: 0.038 ms

**実行計画の読み方**:

- 実行計画は通常、**内側（インデントが深い部分）から外側（インデントが浅い部分）へ**と処理が進みます。
- 各行は「**ノード**」と呼ばれ、DBMS が行う操作（スキャン、ソート、結合など）を示します。
- cost=開始コスト..終了コスト: クエリプロセッサがそのノードを開始するまでのコストと、そのノードの全処理が完了するまでの総コストの推定値です。**コストはディスク I/O と CPU コストを抽象化した相対的な単位**であり、実際の時間とは異なることが多いです。
- rows: そのノードから出力されると推定される行数です。EXPLAIN ANALYZE では actual rows として実際の行数も表示されます。
- width: 出力される行の推定バイト幅です。
- Filter: 特定の条件で絞り込みが行われていることを示します。

### **テーブルスキャン / インデックススキャンの違い (なぜ使い分けるのか？)**

実行計画を分析する上で最も重要な点の 1 つが、データへのアクセス方法です。これは、インデックスの B-Tree 構造を理解していれば、より明確になります。

#### **1\. シーケンシャルスキャン (Sequential Scan / Table Scan)**

- **説明**: テーブルの全行を物理的な順序で最初から最後まで読み込む方法です。ディスク上にデータが連続して格納されている場合、高速に読み込めます。
- **なぜ行われるのか**:
  - **インデックスが存在しない**: 検索条件に使えるインデックスがそもそもない場合、全行を読み込むしかありません。
  - **インデックスが利用できないパターン**: 前述の「ワイルドカード前方一致以外」や「関数適用」などの場合、インデックスの B-Tree を効率的に使えないため、シーケンシャルスキャンが選択されます。
  - **絞り込み効果が低い**: 検索条件で絞り込まれる行の割合が非常に高い場合（例: 全体の 30%以上）は、インデックスを使うよりもテーブル全体を読み込む方が高速と DBMS のオプティマイザが判断することがあります。なぜなら、インデックススキャンは B-Tree を辿る I/O と、各行のテーブル本体への I/O（ブックマークルックアップ）の合計ですが、多数の行を取得する場合は、インデックスから個別にデータを取得する I/O が積み重なるよりも、テーブルの全データを連続的に読み込む（シーケンシャルリード）方が効率的になるためです。
  - **テーブルが非常に小さい**: テーブルのデータ量がディスクの 1 ブロック分しかないなど非常に小さい場合、インデックスを使うオーバーヘッドの方が大きくなるため、シーケンシャルスキャンの方が速いと判断されます。
- **特徴**: 全てのデータにアクセスするため、絞り込みが少ないクエリや集計クエリでは効率的な場合があります。しかし、特定の少数の行を見つけたい場合には非効率的です。

#### **2\. インデックススキャン (Index Scan)**

- **説明**: インデックスの B-Tree 構造を利用して、必要なデータが格納されている行の物理的な位置を特定し、その行だけを効率的に読み込む方法です。
- **なぜ行われるのか**:
  - **インデックスが存在し、利用可能**: 検索条件に合致するインデックスが存在し、かつそれが効率的に使える場合（例: 等価検索、範囲検索、前方一致ワイルドカード）。
  - **絞り込み効果が高い**: 検索条件によって絞り込まれる行の割合が低い場合（例: 数%程度）。これにより、B-Tree の探索（少量の I/O）と、必要な数行分のテーブル本体へのアクセス（少量の I/O）だけで済むため、シーケンシャルスキャンよりもはるかに高速になります。
- **種類**:
  - **インデックスオンリースキャン (Index Only Scan)**: カバリングインデックスが利用可能な場合に、テーブル本体にアクセスせず、インデックスの B-Tree のみで全ての情報を取得します。ディスク I/O がインデックスの読み込みだけで済むため、最も高速なアクセス方法の一つです。ただし、PostgreSQL の場合は前述の VACUUM による可視化の条件を満たす必要があります。
  - **ビットマップインデックススキャン (Bitmap Index Scan)** (PostgreSQL など): 複数のインデックスを組み合わせて複雑な AND/OR 条件を絞り込む場合などに利用されます。各インデックススキャンで得られた行の位置情報（ビットマップ形式）を結合し、最終的な行のセットを効率的に決定した後、まとめてテーブル本体にアクセスします。これにより、個別のブックマークルックアップを減らし、効率化を図ります。

見分け方:  
実行計画のノード名で確認できます。

- Seq Scan → シーケンシャルスキャン
- Index Scan → インデックススキャン (テーブル本体へのアクセスあり)
- Index Only Scan → インデックスオンリースキャン (テーブル本体へのアクセスなし)
- Bitmap Index Scan \+ Bitmap Heap Scan → ビットマップインデックススキャン (インデックスからビットマップを作り、それを使ってまとめてテーブルにアクセス)

### **JOIN 方式 (なぜこのアルゴリズムを選ぶのか？)**

複数のテーブルを結合する際、DBMS はいくつかの異なるアルゴリズム（結合方式）を使い分けます。どの結合方式が選択されるかは、テーブルのサイズ、インデックスの有無、結合条件、データ分散などによって DBMS のオプティマイザが判断します。各方式は、特定のシナリオで最適なパフォーマンスを発揮します。

#### **1\. ネステッドループ結合 (Nested Loop Join)**

- **説明**: 一方のテーブル（外部テーブル）の行を 1 つずつ取り出し、その行に対してもう一方のテーブル（内部テーブル）をループして結合条件に一致する行を探す方法です。
- **なぜ選択されるのか**:
  - **外部テーブルの行数が少ない**: 外部テーブルの行が少ない場合、内部テーブルへの検索回数が少なく済むため効率的です。
  - **内部テーブルにインデックス**: 内部テーブルの結合列に効率的なインデックス（B-Tree）が存在する場合に非常に高速です。外部テーブルの各行から取得した結合キーで、内部テーブルのインデックスを効率的にスキャンして対応する行を見つけられるため、O(NlogM)のような時間計算量（N は外部テーブルの行数、M は内部テーブルの行数）になります。
  - **比較的小規模な結合**: 最も基本的な結合方式であり、比較的小規模な結合や、絞り込み後の結合で頻繁に利用されます。
- **イメージ**:  
  FOR each row in 外部テーブル DO \-- (外部テーブルを 1 行ずつ読み込む)  
   FOR each row in 内部テーブル WHERE 結合条件 DO \-- (内部テーブルを検索。インデックスがあれば高速)  
   出力;  
   END FOR;  
  END FOR;

#### **2\. ハッシュ結合 (Hash Join)**

- **説明**: まず、小さい方のテーブル（ビルド側）の結合列の値をハッシュ関数で変換し、メモリ上にハッシュテーブルを作成します。次に、大きい方のテーブル（プローブ側）の結合列の値を同じハッシュ関数で変換し、ハッシュテーブルをプローブ（検索）して一致する行を探します。
- **なぜ選択されるのか**:
  - **結合する両方のテーブルにインデックスがなくても高速**: 大規模なテーブル間の結合で、結合列にインデックスがなくても高速な処理が可能です。インデックスが存在しない場合や、インデックススキャンでは効率が悪いと判断される場合に強力な選択肢となります。
  - **等価条件 (=) の結合**: 特に、結合列が等価条件（=）である場合に効果的です。ハッシュ関数の性質上、等価比較に最適化されています。
  - **大規模な結合**: ビルド側のテーブルがメモリに収まる程度であれば、O(N+M)に近い時間計算量で処理できるため、非常に効率的です。
  - **メモリ消費**: メモリを多く消費するため、ビルド側のテーブルが非常に大きい場合はハッシュテーブルがメモリに収まらず、ディスクへの書き出し（ハッシュバケットのスピル）が発生し、パフォーマンスが低下する可能性があります。
- **イメージ**:
  1. **ビルドフェーズ**: 小さい方のテーブルの結合列からハッシュテーブルを構築。
  2. **プローブフェーズ**: 大きい方のテーブルの結合列をハッシュテーブルで検索。

#### **3\. マージ結合 (Merge Join)**

- **説明**: 結合する両方のテーブル（または中間結果）を、結合列でソートします。その後、ソートされた 2 つのテーブルを先頭から順にスキャンしていき、結合条件に一致する行をマージ（結合）します。
- **なぜ選択されるのか**:
  - **結合列が既にソートされている**: 結合列に既にインデックスがあり、それがソート順になっている場合（例: プライマリキーや B-Tree インデックスを持つ列）や、両方のテーブルが結合列でソートされている場合に非常に高速です。ソートにかかるコストが不要になるため、O(N+M)の時間計算量で処理できます。
  - **ソートされていない場合のコスト**: ソートされていないテーブルに対しては、最初にソート処理（I/O と CPU を消費）が発生するため、そのコストが追加されます。このソート処理が大きなボトルネックになることもあります。
  - **範囲条件 (\>, \<, BETWEEN) による結合**: ネステッドループ結合やハッシュ結合に比べて、範囲条件による結合でも利用可能です。
- **イメージ**:
  1. **ソートフェーズ**: 両テーブルを結合列でソート（必要であれば）。
  2. **マージフェーズ**: ソート済みテーブルを同時にスキャンし、一致する行を結合。

結合方式の見分け方:  
実行計画のノード名で確認できます。

- Nested Loop → ネステッドループ結合
- Hash Join → ハッシュ結合
- Merge Join → マージ結合

## **実務で役立つパフォーマンスチューニングのワークフロー**

遅いクエリに出会った際に、どのようにパフォーマンスを改善していくかの一般的なワークフローをまとめます。

1. **遅いクエリの特定**:
   - アプリケーションのログやデータベースの監視ツールなどから、実行時間の長いクエリを特定します。
2. **EXPLAIN ANALYZE で実行計画の確認**:
   - 特定したクエリに対して EXPLAIN ANALYZE を実行し、実際の実行計画と統計情報を取得します。
   - この際、EXPLAIN で推定コストだけを見るのではなく、**必ず ANALYZE を使って実際の時間や行数を確認する**ことが重要です。
3. **実行計画の分析**:
   - **テーブルスキャンが頻繁に発生していないか**: 特に、少数の行を絞り込みたい場面で Seq Scan が出ている場合は、インデックスの検討が必要です。
   - **コストの高いノード（ボトルネック）を特定**: actual time が長くかかっているノードや、rows の推定値と実測値が大きく乖離しているノードに注目します。
   - **インデックスの利用状況**: 意図したインデックスが使われているか、Index Only Scan が利用されているかを確認します。
   - **JOIN 方式の確認**: 大規模なテーブル結合で非効率な Nested Loop が選ばれていないかなどを確認します。
4. **改善策の検討と実施**:
   - **インデックスの追加・修正**:
     - 検索条件（WHERE 句）やソート条件（ORDER BY 句）に使われている列に、適切な単一列インデックスや複合インデックスを作成します。
     - SELECT 句に含まれる列が多い場合は、カバリングインデックス（INCLUDE 句）を検討します。
     - 特定の条件で絞り込まれる行が多い場合は、部分インデックスを検討します。
     - LIKE '%...'のようにインデックスが効かないパターンになっていないか確認し、可能であればクエリを書き換えるか、関数インデックスや演算子クラスの指定を検討します。
   - **クエリの書き換え**:
     - サブクエリをより効率的な JOIN や**ウィンドウ関数**に書き換えることを検討します。
     - 不要な JOIN や列の取得がないか確認します。
     - OR 条件を UNION で書き換えるなど、より DBMS が最適化しやすい形に変更します。
   - **統計情報の更新**:
     - テーブルのデータが大幅に増減した場合、ANALYZE コマンド（PostgreSQL の場合）で統計情報を更新すると、DBMS がより正確な実行計画を立てられるようになります。
5. **効果の検証**:
   - 改善策を実施した後、再度 EXPLAIN ANALYZE を実行し、パフォーマンスが実際に向上したか、実行計画が改善されたかを確認します。

この繰り返しによって、データベースのパフォーマンスは持続的に向上していきます。

## **まとめ**

インデックスと実行計画は、データベースのパフォーマンスを理解し、改善するための強力なツールです。

- **インデックス**:
  - B-Tree というソートされた階層構造によって、特定のデータへの高速なアクセスを可能にします。
  - 検索やソートを高速化するために、適切な列に適切な種類のインデックス（単一列、複合、カバリング、部分、ユニーク）を作成することが重要です。
  - B-Tree の特性上、インデックスが効かないパターン（前方ワイルドカード、関数適用など）があることを理解し、クエリの書き方を工夫するか、関数インデックスや演算子クラスなどの代替手段を検討することが必要です。
  - インデックスは更新コストやストレージ消費といったデメリットもあるため、闇雲に増やさず、必要に応じて作成・見直すことが肝要です。
- **実行計画**:
  - EXPLAIN や EXPLAIN ANALYZE を使って、DBMS がどのようにクエリを実行しているかを把握します。
  - テーブルスキャンとインデックススキャンの違い、そしてネステッドループ、ハッシュ結合、マージ結合といった JOIN 方式の特性を、それぞれのアルゴリズムが「なぜそのように機能するのか」という根本原理とともに理解することで、ボトルネックを特定し、より効率的なクエリやインデックス戦略を立てることができます。

これらの知識を活用することで、アプリケーションの応答速度を向上させ、データベースシステム全体の安定稼働に貢献できるようになります。

この資料が、インデックスと実行計画の理解を深める一助となれば幸いです。  
他に質問があれば、お気軽にお尋ねください。
