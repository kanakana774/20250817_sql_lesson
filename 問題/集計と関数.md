EC サイトデータ 集計・関数問題集
集計とグループ化に関する問題
問題 1: 全商品数とカテゴリ数
重要度: ★★★★
問題目的: COUNT(_)と COUNT(DISTINCT 列名)を使用して、テーブルの全行数と重複を除いた要素数をカウントする方法を理解する。
問題:
products_mst テーブルに登録されている全商品数をカウントしてください。
products_mst テーブルに登録されているユニークなカテゴリ数をカウントしてください。
答え:
全商品数
SELECT COUNT(_) AS total_products
FROM products_mst;

ユニークなカテゴリ数
SELECT COUNT(DISTINCT category) AS unique_categories
FROM products_mst;

問題 2: 商品の合計価格と平均価格
重要度: ★★★★
問題目的: SUM()と AVG()を使用して、数値列の合計値と平均値を算出する方法を理解する。
問題: products_mst テーブルに登録されている全商品の価格の合計と平均価格をそれぞれ算出してください。
答え:
SELECT
SUM(price) AS total_price,
AVG(price) AS average_price
FROM products_mst;

問題 3: 最も安い商品と最も高い商品の価格
重要度: ★★★★
問題目的: MIN()と MAX()を使用して、列の最小値と最大値を特定する方法を理解する。
問題: products_mst テーブルから、最も安い商品の価格と最も高い商品の価格をそれぞれ取得してください。
答え:
SELECT
MIN(price) AS min_product_price,
MAX(price) AS max_product_price
FROM products_mst;

問題 4: カテゴリごとの商品数と平均価格
重要度: ★★★★★
問題目的: GROUP BY 句を使用して、特定の列（カテゴリ）でデータをグループ化し、グループごとに集計関数を実行する方法を理解する。
問題: products_mst テーブルから、カテゴリごとに商品数と平均価格を算出してください。
答え:
SELECT
category,
COUNT(\*) AS product_count,
AVG(price) AS average_price
FROM products_mst
GROUP BY category;

問題 5: 高価格帯の商品が多いカテゴリを特定する
重要度: ★★★★★
問題目的: HAVING 句を使用して、GROUP BY で集計された結果に対して条件を指定し、フィルタリングする方法を理解する。
問題: products_mst テーブルから、平均価格が 5000 円より大きいカテゴリを抽出し、そのカテゴリ名、商品数、平均価格を表示してください。
答え:
SELECT
category,
COUNT(\*) AS product_count,
AVG(price) AS average_price
FROM products_mst
GROUP BY category
HAVING AVG(price) > 5000;

問題 6: 在庫が特定の数量以上の商品のカテゴリ別集計
重要度: ★★★★★
問題目的: WHERE 句で集計前の行フィルタリングを行い、その後に GROUP BY と HAVING を組み合わせて集計後のグループをフィルタリングする処理順序を理解する。
問題: products_mst テーブルから、在庫数(stock_quantity)が 100 個以上の商品のみを対象に、カテゴリごとの商品数を算出してください。ただし、商品数が 2 つ以上のカテゴリのみを表示してください。
答え:
SELECT
category,
COUNT(_) AS product_count
FROM products_mst
WHERE stock_quantity >= 100 -- まず、在庫数 100 個以上の商品に絞り込む
GROUP BY category
HAVING COUNT(_) >= 2; -- その後、グループ化された結果で商品数が 2 つ以上のものを抽出

関数に関する問題
問題 7: 顧客名とメールアドレスを結合して表示する
重要度: ★★★★
問題目的: CONCAT()関数または||演算子を使用して、複数の文字列を結合する方法を理解する。
問題: customers_mst テーブルから、顧客の名前とメールアドレスを CONCAT 関数（または||演算子）で結合し、「顧客名 (メールアドレス)」の形式で表示してください。エイリアスは customer_contact としてください。
答え:
SELECT
CONCAT(customer_name, ' (', email, ')') AS customer_contact
FROM customers_mst;

バリエーション (PostgreSQL の||演算子):
SELECT
customer_name || ' (' || email || ')' AS customer_contact
FROM customers_mst;

問題 8: 商品名の短縮形と大文字・小文字変換
重要度: ★★★★
問題目的: SUBSTRING(), UPPER(), LOWER()関数を使用して文字列を加工する方法を理解する。
問題: products_mst テーブルから、以下の形式で商品名を表示してください。
商品名の最初の 3 文字を抽出して表示する (short_name として)。
商品名を全て大文字に変換して表示する (upper_name として)。
商品名を全て小文字に変換して表示する (lower_name として)。
答え:
SELECT
product_name,
SUBSTRING(product_name FROM 1 FOR 3) AS short_name,
UPPER(product_name) AS upper_name,
LOWER(product_name) AS lower_name
FROM products_mst;

問題 9: 商品メモの空白を除去する
重要度: ★★★★
問題目的: TRIM()関数を使用して、文字列の両端の空白文字を除去する方法を理解する。
問題: products_mst テーブルの memo 列に、もし余分な空白が含まれている場合を想定し、その空白を両端から除去したメモの内容を表示してください。元のメモとトリム後のメモの両方を表示し、メモが NULL ではないもののみを対象とします。
答え:
SELECT
product_name,
memo AS original_memo,
TRIM(memo) AS trimmed_memo
FROM products_mst
WHERE memo IS NOT NULL;

問題 10: 現在の日付と時刻を取得し、特定の形式で表示する
重要度: ★★★★
問題目的: NOW()または CURRENT_TIMESTAMP で現在日時を取得し、TO_CHAR()で日付を整形する方法を理解する。
問題:
現在のシステム日時を取得してください。
現在のシステム日時を「YYYY 年 MM 月 DD 日 HH 時 MI 分 SS 秒」の形式で表示してください。
答え:
現在のシステム日時
SELECT NOW() AS current_datetime;

整形された現在日時
SELECT TO_CHAR(NOW(), 'YYYY 年 MM 月 DD 日 HH24 時 MI 分 SS 秒') AS formatted_datetime;

問題 11: 注文日の翌週の同じ曜日を計算する
重要度: ★★★★★
問題目的: INTERVAL キーワードを使用して日付に期間を加算する方法を理解する。
問題: orders_trn テーブルから、各注文の注文日と、その注文日の**7 日後（翌週の同じ曜日）**の日付を計算して表示してください。
答え:
SELECT
order_id,
order_date,
order_date + INTERVAL '7 day' AS next_week_date
FROM orders_trn;

問題 12: 顧客の登録月を抽出する
重要度: ★★★★
問題目的: EXTRACT()関数を使用して日付から特定の部分（月）を抽出する方法を理解する。
問題: customers_mst テーブルから、各顧客の登録日（created_date）の月を数値で抽出して表示してください。
答え:
SELECT
customer_name,
created_date,
EXTRACT(MONTH FROM created_date) AS registration_month
FROM customers_mst;

問題 13: 注文日の曜日名を表示する
重要度: ★★★★★
問題目的: TO_CHAR()関数を使用して日付から曜日名を抽出する方法を理解する。
問題: orders_trn テーブルから、各注文の注文日と、その注文日が何曜日かを日本語のフルネーム（例: '月曜日', '火曜日'）で表示してください。
答え:
SELECT
order_id,
order_date,
TO_CHAR(order_date, 'Day') AS order_day_of_week -- PostgreSQL では'Day'が曜日名を返す
FROM orders_trn;

補足: PostgreSQL の TO_CHAR 関数は、環境のロケール設定によっては英語の曜日名（e.g., 'Monday')を返す場合があります。日本語の曜日名を得るには LC_TIME 設定などが必要になることがありますが、基本的な使い方として'Day'を指定します。
新しい集計・関数に関する問題
問題 14: 注文ごとの異なる商品点数と合計購入個数
重要度: ★★★★★
問題目的: COUNT(DISTINCT 列名)と SUM()を組み合わせて、各グループ内でユニークな要素の数と合計を算出する方法を理解する。
問題: order_details_trn テーブルから、注文 ID(order_id)ごとに異なる商品の種類数（商品点数）と、その注文における合計購入個数(quantity)を算出してください。
答え:
SELECT
order_id,
COUNT(DISTINCT product_id) AS distinct_product_count,
SUM(quantity) AS total_quantity_ordered
FROM order_details_trn
GROUP BY order_id;

問題 15: 顧客の登録年ごとの顧客数
重要度: ★★★★
問題目的: EXTRACT()関数で日付から年を抽出し、その年でグループ化して集計を行う方法を理解する。
問題: customers_mst テーブルから、顧客の登録年(created_date)ごとに登録された顧客の数を算出してください。
答え:
SELECT
EXTRACT(YEAR FROM created_date) AS registration_year,
COUNT(\*) AS customer_count
FROM customers_mst
GROUP BY registration_year
ORDER BY registration_year;

問題 16: 平均価格が高く、かつ特定の高価格帯の商品を含むカテゴリの抽出
重要度: ★★★★★
問題目的: WHERE 句と HAVING 句をより複雑に組み合わせ、集計前と集計後の両方で条件を適用する。
問題: products_mst テーブルから、価格が 10000 円より高い商品が少なくとも 1 つ含まれるカテゴリで、かつそのカテゴリの平均価格が 15000 円より大きいものを抽出し、カテゴリ名、商品数、平均価格を表示してください。
答え:
SELECT
category,
COUNT(\*) AS product_count,
AVG(price) AS average_price
FROM products_mst
WHERE product_id IN (SELECT product_id FROM products_mst WHERE price > 10000) -- 価格が 10000 円より高い商品が含まれるカテゴリを対象とする（集計前のフィルタリング）
GROUP BY category
HAVING AVG(price) > 15000; -- 集計後の平均価格でフィルタリング

補足: この問題はサブクエリを使用していますが、集計とグループ化の理解を深めるために重要です。WHERE 句で先に特定の条件を満たす行を絞り込むことで、GROUP BY と HAVING の処理が効率化されることを示唆しています。
問題 17: 顧客メールアドレスのドメイン名抽出
重要度: ★★★★★
問題目的: 文字列関数を組み合わせて、特定のパターン（この場合は@より後ろ）を抽出する方法を理解する。
問題: customers_mst テーブルから、各顧客のメールアドレスからドメイン名のみを抽出して表示してください。（例: sato.taro@example.com から example.com を抽出）
答え:
SELECT
customer_name,
email,
SUBSTRING(email FROM POSITION('@' IN email) + 1) AS email_domain
FROM customers_mst;

バリエーション (PostgreSQL の SPLIT_PART 関数):
SELECT
customer_name,
email,
SPLIT_PART(email, '@', 2) AS email_domain
FROM customers_mst;

問題 18: 注文から 90 日後の日付を計算し、月別で集計
重要度: ★★★★★
問題目的: 日付の加算と EXTRACT()関数、GROUP BY を組み合わせ、計算後の日付で集計する方法を理解する。
問題: orders_trn テーブルから、各注文の注文日から 90 日後の日付を計算してください。その上で、その「90 日後の日付」の月ごとに、該当する注文の数を算出してください。
答え:
SELECT
EXTRACT(MONTH FROM (order_date + INTERVAL '90 day')) AS calculated_month,
COUNT(\*) AS orders_count
FROM orders_trn
GROUP BY calculated_month
ORDER BY calculated_month;

問題 19: 商品名の文字長を取得する
重要度: ★★★★
問題目的: LENGTH()または CHAR_LENGTH()関数を使用して、文字列の長さを取得する方法を理解する。
問題: products_mst テーブルから、商品名とその文字長を両方表示してください。
答え:
SELECT
product_name,
LENGTH(product_name) AS product_name_length -- 文字列のバイト長を返す場合がある (ASCII 文字以外は注意)
-- CHAR_LENGTH(product_name) AS product_name_char_length -- 文字数を返す (PostgreSQL 推奨)
FROM products_mst;

補足: LENGTH()は多くの場合バイト長を返しますが、PostgreSQL では文字数を返します。より確実に文字数を取得するには CHAR_LENGTH()（または CHARACTER_LENGTH()）が推奨されます。
問題 20: NULL のメモを「メモなし」と表示する
重要度: ★★★★★
問題目的: COALESCE()関数を使用して、NULL 値が返される可能性のある式や列に対して、代替の非 NULL 値を指定する方法を理解する。
問題: products_mst テーブルから、商品名とメモを表示してください。ただし、メモ(memo)が NULL の場合は、'メモなし'という文字列を代わりに表示してください。
答え:
SELECT
product_name,
COALESCE(memo, 'メモなし') AS display_memo
FROM products_mst;

補足: COALESCE 関数は引数を左から順に評価し、最初に NULL ではない値を返します。これにより、NULL 値をユーザーにとって分かりやすい代替値に変換できます。
これらの追加問題で、集計、グループ化、そして文字列・日付関数、さらに NULL 値の扱いや結合的なクエリの理解をより一層深めることができるかと思います。
次に、残りの ALTER TABLE や DROP TABLE に関する問題、あるいはテーブル間の結合（JOIN）に焦点を当てた問題に進みますか？
